<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SongX64</title>
  
  <subtitle>SongX64的博客</subtitle>
  <link href="https://songx64.github.io/atom.xml" rel="self"/>
  
  <link href="https://songx64.github.io/"/>
  <updated>2021-09-22T12:06:56.953Z</updated>
  <id>https://songx64.github.io/</id>
  
  <author>
    <name>SongX64</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20210902神策后端笔试</title>
    <link href="https://songx64.github.io/2021/09/02/20210902%E7%A5%9E%E7%AD%96%E6%95%B0%E6%8D%AE%E7%AC%94%E8%AF%95/"/>
    <id>https://songx64.github.io/2021/09/02/20210902%E7%A5%9E%E7%AD%96%E6%95%B0%E6%8D%AE%E7%AC%94%E8%AF%95/</id>
    <published>2021-09-02T09:53:41.000Z</published>
    <updated>2021-09-22T12:06:56.953Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="20210902神策后端笔试"><a href="#20210902神策后端笔试" class="headerlink" title="20210902神策后端笔试"></a>20210902神策后端笔试</h1><p>神策数据后端，8/31发的笔试链接，3日内做完就行。牛客网笔试。</p><hr><p>10道单选，5道多选，3道编程题。<br>哇神策编程题就那几个吗。。。好多人都是重题。实不相瞒我看了两个笔经，碰到了。</p><p>感谢大佬的分享：</p><ul><li><a href="https://blog.csdn.net/DJames23/article/details/119580419">【0810神策数据笔试】java3道编程</a></li><li><a href="https://ac.nowcoder.com/discuss/719746">神策数据后端开发8.25笔试</a></li></ul><hr><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>题目简述：</p><p><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><ol><li>括号匹配：字符串(1)23(4()5)6，输出里面每对括号对应下标（必然匹配）。</li><li>很赞的整数对：三个数x,y,m。(x,y)里面有一个数大于m，就是很赞的整数对。</li><li>字符串去除重复空格，每个单词进行反转</li></ol><h3 id="第一题：字符串、有效括号数"><a href="#第一题：字符串、有效括号数" class="headerlink" title="第一题：字符串、有效括号数"></a>第一题：字符串、有效括号数</h3><p>给定一个字符串，打印里面匹配的括号的个数和下标，比如：<br>(1)23(4()5)6，一共有三对括号，下标0和2是一对，5和10是一对，7和8是一对。输入数据的括号均能成对出现，以下输入是不存在的：((1)<br>输入描述：一个包含数字和括号的字符串，一行<br>输出描述：多行输出，第一行是成对括号的个数，后面每行是一个括号的下标。</p><blockquote><p>输入：(1)<br>输出：<br>1<br>0<br>2<br>说明：共有1对成对的括号，其下标为0和2</p></blockquote><p><strong>栈的应用，不过有点坑的是<u>输出需要从小到大</u>：</strong></p><p><strong>比如还是上面题目里的例子，  必须要这样输出<code>0  2  5  10   7  8 </code>才可以，也就是第一个括号下标要 <code>0,5,7</code> 这样从小到大有序输出。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2021/9/2,下午 4:15</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SongX64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()){</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            TreeMap&lt;Integer,Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) {</span><br><span class="line">                <span class="keyword">if</span>(chars[i] == <span class="string">'('</span>){</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">')'</span>){</span><br><span class="line">                    treeMap.put(stack.pop(),i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(treeMap.keySet().size());</span><br><span class="line">            <span class="keyword">for</span> (Integer key : treeMap.keySet()){</span><br><span class="line">                System.out.println(key);</span><br><span class="line">                System.out.println(treeMap.get(key));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="第二题：很赞的整数对"><a href="#第二题：很赞的整数对" class="headerlink" title="第二题：很赞的整数对"></a>第二题：很赞的整数对</h3><p>题目：给一个整数对(x,y)，并且允许把其中一个数修改成之前两个数的和，x+y。比如(5,2)，两数之和为7，经过一次修改可以变成(7,2)或(5,7)。再给一个整数m，问至少要做多少次上述修改操作，才能使两个数组成的数对是对m很赞的整数对。两个数中至少有一个数大于等于m，这个数对就是很赞的整数对。</p><p>输入描述：一行包含3个整数，分别是x,y,m。其中x，y是最初的两个整数，取值范围是int32；m是一个整数，取值范围是int32；<br>输出描述：至少要做多少次上述修改操作，才能使得数对为m的很赞整数对。</p><blockquote><p>输入： 1 2 5<br>输出： 2<br>说明：经过2次操作，一种可行的但不一定是最优的操作方法是：(1,2)–&gt;(3,2)–&gt;(5,2)</p><p>输入：-1 4 15<br>输出： 4<br>说明：最少经过4次操作，一种可行的但不一定是最优的操作方法是：(-1,4)–&gt;(3,4)–&gt;(7,4)–&gt;(11,4)–&gt;(15,4) </p><p>输入： 0 -1 5<br>输出： -1<br>说明：经过多少次操作都无法满足要求，输出-1</p></blockquote><p><strong>最终AC95点几。。。实在想不出来了。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2021/9/2,下午 4:25</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SongX64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">// 越界问题，所以说用Long来避免</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLong()) {</span><br><span class="line">            <span class="keyword">long</span> x = scanner.nextLong();</span><br><span class="line">            <span class="keyword">long</span> y = scanner.nextLong();</span><br><span class="line">            <span class="keyword">long</span> m = scanner.nextLong();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环控制标志</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 已经满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (m &lt;= x || m &lt;= y) {</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 不满足条件，进行操作</span></span><br><span class="line">                <span class="comment">// m为正，xy有0</span></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) {</span><br><span class="line">                    count = -<span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 相加永久等于0</span></span><br><span class="line">                <span class="keyword">if</span> (m != <span class="number">0</span> &amp;&amp; x + y == <span class="number">0</span>) {</span><br><span class="line">                    count = -<span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 不满足条件，且x和y都小于0，xy只会越加越小</span></span><br><span class="line">                <span class="keyword">if</span> ( x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span>) {</span><br><span class="line">                    <span class="comment">// m为正，xy都为负数</span></span><br><span class="line">                    count = -<span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 判断通过，进行操作</span></span><br><span class="line">            <span class="comment">// 若有一个大于等于m，就可以了</span></span><br><span class="line">            <span class="keyword">while</span> (flag &amp;&amp; x &lt; m &amp;&amp; y &lt; m) {</span><br><span class="line">                <span class="comment">// 选择一个较小的进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt;= y) {</span><br><span class="line">                    x += y;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    y += x;</span><br><span class="line">                }</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="第三题：字符串反转"><a href="#第三题：字符串反转" class="headerlink" title="第三题：字符串反转"></a>第三题：字符串反转</h3><p>给定字符串s,要求把s中多于一个的连续空压缩成一个空格，并将连续的非空格字符串倒序打印出来，例如，给定”abc def efg”，打印”cba fed gfe”。</p><blockquote><p>输入：abc def efg<br>输出： cba fed gfe</p></blockquote><p>直接字符数组处理的，AC100。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2021/9/2,下午 4:38</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SongX64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) {</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            s.trim();</span><br><span class="line">            <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 快慢指针</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; ) {</span><br><span class="line">                <span class="comment">// 快指针找到空格</span></span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; chars.length &amp;&amp; chars[j] != <span class="string">' '</span>) {</span><br><span class="line">                    j++;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 记录单词末尾空格位置，然后逆序单词</span></span><br><span class="line">                <span class="keyword">int</span> temp = j;</span><br><span class="line">                <span class="keyword">while</span> (j!=i){</span><br><span class="line">                    j--;</span><br><span class="line">                    stringBuilder.append(chars[j]);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 添加一个空格，之后慢指针跳过多个空格</span></span><br><span class="line">                stringBuilder.append(<span class="string">' '</span>);</span><br><span class="line">                i = temp;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; chars.length &amp;&amp; chars[i] == <span class="string">' '</span>){</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            System.out.println(stringBuilder);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;20210902神策后端笔试&quot;&gt;&lt;a href=&quot;#20210902神策后端笔试&quot; class=&quot;headerlink&quot; title=&quot;20210902神策后端笔试&quot;&gt;&lt;/a&gt;20210902神策后端笔试&lt;/h1&gt;&lt;p&gt;神策数据后端，8/</summary>
      
    
    
    
    <category term="算法" scheme="https://songx64.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://songx64.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring原理及应用——Offer来了框架篇第一章</title>
    <link href="https://songx64.github.io/2021/08/06/Offer%E6%9D%A5%E4%BA%86%E6%A1%86%E6%9E%B6%E7%AF%871Spring%E5%8E%9F%E7%90%86/"/>
    <id>https://songx64.github.io/2021/08/06/Offer%E6%9D%A5%E4%BA%86%E6%A1%86%E6%9E%B6%E7%AF%871Spring%E5%8E%9F%E7%90%86/</id>
    <published>2021-08-06T10:11:35.000Z</published>
    <updated>2021-08-06T11:24:32.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring原理及应用"><a href="#Spring原理及应用" class="headerlink" title="Spring原理及应用"></a>Spring原理及应用</h1><p>[TOC]</p><h2 id="1-1-Spring特性"><a href="#1-1-Spring特性" class="headerlink" title="1.1 Spring特性"></a>1.1 Spring特性</h2><p>问：Spring有哪些特点？</p><p><strong>轻量级、控制反转、面向切面、面向容器、灵活。</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">Spring特性---轻量级</span><br><span class="line">Spring特性---控制反转</span><br><span class="line">Spring特性---面向容器</span><br><span class="line">Spring特性---面向切面</span><br><span class="line">Spring特性---灵活</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol><li>轻量级<ul><li>核心Jar包小</li><li>模块化，按需引入</li></ul></li><li>控制反转<ul><li>一个对象所<strong>依赖的其他对象</strong>会自动传递给它</li><li>实现对象依赖的解耦</li></ul></li><li>面向切面<ul><li>提高系统内聚性</li><li>抽取公共的业务，只需关注核心业务</li></ul></li><li>面现容器<ul><li>实现了对象配置化生成</li><li>实现了对象生命周期管理</li></ul></li><li>框架灵活<ul><li>对象可以声明式创建</li></ul></li></ol><blockquote><p>补充：JavaBean</p><p>JavaBean是一种Java类，通过<strong>封装属性和方法</strong>成为具有某种功能，或者是处理某个业务的对象。必须有一个<strong>缺省的构造函数</strong>，每个属性都有<strong>get\set方法</strong>，<strong>可序列化</strong>。</p></blockquote><h2 id="1-2-Spring模块"><a href="#1-2-Spring模块" class="headerlink" title="1.2 Spring模块"></a>1.2 Spring模块</h2><p>Spring是模块化的，可以按需引入。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/2021022317001862.png" alt="Spring模块"></p><p>常用模块有：核心容器层Core Container，数据访问层Data Access，Web应用层Web Access。</p><h3 id="1-2-1-核心容器层"><a href="#1-2-1-核心容器层" class="headerlink" title="1.2.1 核心容器层"></a>1.2.1 核心容器层</h3><p>主要有 Srping-Beans、Spring-Core、Spring-Context、SpEL等模块组成。</p><h4 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring-Beans *"></a>Spring-Beans *</h4><p>基于 <strong>工厂模式</strong> 实现 <strong>对象的创建</strong> 。XML或者注解实现声明式的对象管理。</p><h4 id="Spring-Core"><a href="#Spring-Core" class="headerlink" title="Spring-Core *"></a>Spring-Core *</h4><p>Spring<strong>核心功能</strong>实现，包括<strong>控制反转IOC</strong>和<strong>依赖注入DI</strong>。</p><p>控制反转模式/思想是通过依赖注入方法来实现的。在某个实例中引用另一个Bean实例的时候，Spring会自动将此实例传入。</p><h4 id="Spring-Context"><a href="#Spring-Context" class="headerlink" title="Spring-Context"></a>Spring-Context</h4><p>继承自Spring-Beans，实现国际化、上下文、事件传播、第三方库集成等等功能。</p><h4 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h4><p>Spring 表达式语言，Spring  Expression Language。</p><p>用于在运行过程中查询和操作对象实例。</p><h3 id="1-2-2-数据访问层"><a href="#1-2-2-数据访问层" class="headerlink" title="1.2.2 数据访问层"></a>1.2.2 数据访问层</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210223171500114.png" alt="术语"></p><h4 id="1-JDBC"><a href="#1-JDBC" class="headerlink" title="1. JDBC *"></a>1. JDBC *</h4><p>Spring持久化层基于JDBC抽象层实现了在不同数据库之间灵活切换，而不用担心不同数据库之间SQL语法的不兼容。</p><h4 id="2-ORM"><a href="#2-ORM" class="headerlink" title="2.ORM *"></a>2.ORM *</h4><p>对象\关系映射。</p><p><strong>对象属性与关系型数据库中的字段进行映射。</strong></p><p>ORM模块提供了对象关系映射API的集成，包括JPA（Java Persistence API）、JDO（Java DataObject）和Hibernate等。基于该模块，ORM框架能很容易地和Spring的其他功能（例如事务管理）整合。</p><h4 id="3-OXM"><a href="#3-OXM" class="headerlink" title="3.OXM"></a>3.OXM</h4><p>OXM模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。</p><h4 id="4-JMS"><a href="#4-JMS" class="headerlink" title="4.JMS *"></a>4.JMS *</h4><p>JMS模块包含消息的生产（Produce）和消费（Consume）功能。从Spring 4.1开始，Spring集成了Spring-Messaging模块，用于实现对<strong>消息队列的支持</strong>。</p><h4 id="5-事务处理"><a href="#5-事务处理" class="headerlink" title="5. **事务处理 ***"></a>5. **事务处理 ***</h4><p>Spring声明式事务只需要<strong>通过注解或配置</strong>即可实现事务的管理，具体的事务管理工作由<strong>Spring自动处理</strong>，应用程序不需要关心事务的提交（Commit）和回滚（Rollback）。</p><h3 id="1-2-3-Web应用层"><a href="#1-2-3-Web应用层" class="headerlink" title="1.2.3 Web应用层"></a>1.2.3 Web应用层</h3><p><strong>Web交互和数据传输功能。</strong></p><p>主要包含Web、Web-MVC、Web-Socket、Web-Portlet。</p><h4 id="Web"><a href="#Web" class="headerlink" title="Web *"></a>Web *</h4><p>Web应用基本功能，HTTP客户端及Spring远程调用中与Web相关的部分。</p><p><strong>Web模块基于Servlet监听器初始化IoC容器。</strong></p><h4 id="Web-MVC"><a href="#Web-MVC" class="headerlink" title="Web-MVC *"></a>Web-MVC *</h4><p>Web-MVC模块为Web应用提供了<strong>MVC和REST API服务的实现</strong>。</p><p>Spring的MVC框架使数据模型和视图分离，数据模型负责数据的业务逻辑，视图负责数据的展示。</p><p>同时，Web-MVC可与Spring框架的其他模块方便地集成。</p><h4 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web-Socket"></a>Web-Socket</h4><p>Web-Socket模块提供了对<strong>WebSocket-Base的支持，</strong>用于实现在Web应用程序中<strong>服务端和客户端实时双向通信</strong>，尤其在实时消息推送中应用广泛。</p><h4 id="Web-Portlet-没用过"><a href="#Web-Portlet-没用过" class="headerlink" title="Web-Portlet(没用过)"></a>Web-Portlet(没用过)</h4><p>Web-Portlet模块提供了基于Portlet环境的MVC实现，并提供了与Spring Web-MVC模块相关的功能。</p><h2 id="1-3核心Jar包"><a href="#1-3核心Jar包" class="headerlink" title="1.3核心Jar包"></a>1.3核心Jar包</h2><p>其实就是上面说的各种模块的Jar包。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210223172309936.png" alt="JAR包1"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210223172322807.png" alt="JAR包2"></p><h2 id="1-4-Spring注解"><a href="#1-4-Spring注解" class="headerlink" title="1.4 Spring注解"></a>1.4 Spring注解</h2><h3 id="1-4-1注解配置"><a href="#1-4-1注解配置" class="headerlink" title="1.4.1注解配置"></a>1.4.1注解配置</h3><p>SpringBoot自动配置，使用XML的就不看了</p><h3 id="1-4-2-常用注解"><a href="#1-4-2-常用注解" class="headerlink" title="1.4.2 常用注解"></a>1.4.2 常用注解</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210224184801412.png" alt="img"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210224184815705.png" alt="img"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210224184828461.png" alt="img"></p><p>整理一下自己常用的，或者说应该知道的</p><table><thead><tr><th>类别</th><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>Bean声明</td><td>@Component</td><td>组件，没有明确定义的角色</td></tr><tr><td></td><td>@Service</td><td>服务</td></tr><tr><td></td><td>@Controller</td><td>控制器</td></tr><tr><td>Bean注入</td><td>@Autowired</td><td>服务依赖注入</td></tr><tr><td>配置类注解</td><td>@Configuration</td><td>声明此类为配置类，包含Value属性可以直接指定属性值</td></tr><tr><td></td><td>@Bean</td><td>注解在方法上，声明该方法返回值注入容器中</td></tr><tr><td></td><td>@ComponentScan</td><td>对组件进行扫描</td></tr><tr><td>AOP注解</td><td>@Aspect</td><td>声明一个切面，使用@After等注解定义通知，可将拦截规则（切点）作为参数</td></tr><tr><td></td><td>@After</td><td>在方法后执行</td></tr><tr><td></td><td>@Before</td><td>在方法前执行</td></tr><tr><td></td><td>@Around</td><td>在方法前和后执行</td></tr><tr><td></td><td>@PonitCut</td><td>声明切点</td></tr><tr><td>SpringMVC注解</td><td>@Controller</td><td>控制器</td></tr><tr><td></td><td>@RequestMapping</td><td>映射Web请求的地址和参数，包括访问路径和参数</td></tr><tr><td></td><td>@ResponseBody</td><td>可以返回JSON到前端</td></tr><tr><td></td><td>@RequestBody</td><td>可以将Request参数放入Request Body体中</td></tr><tr><td></td><td>@RestController</td><td>@Controller和@ResponseBody的结合，可以返回消息的一个Controller</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="1-5-IOC原理"><a href="#1-5-IOC原理" class="headerlink" title="1.5 IOC原理"></a>1.5 IOC原理</h2><h3 id="1-5-1-IOC简介"><a href="#1-5-1-IOC简介" class="headerlink" title="1.5.1 IOC简介"></a>1.5.1 IOC简介</h3><p>Spring通过一个配置文件描述Bean和Bean之间的<strong>依赖关系</strong>，利用Java的<strong>反射功能</strong>实例化Bean并建立Bean之间的依赖关系。</p><hr><p>抽象工厂+反射。</p><p>先读取配置文件，后生成实例。</p><p>根据类名动态生成对象：<code>f = (类名) class.forName(类名字符串).newInstance()</code> </p><h3 id="1-5-2-Bean装配流程"><a href="#1-5-2-Bean装配流程" class="headerlink" title="1.5.2 Bean装配流程"></a>1.5.2 Bean装配流程</h3><ol><li>读取配置、注解信息</li><li>读取Bean配置信息：Spring在启动时会从XML配置文件或注解中<strong>读取</strong>应用程序提供的Bean<strong>配置信息</strong></li><li>并在Spring容器中生成一份相应的<strong>Bean配置注册表</strong>；</li><li>然后根据这张注册表<strong>实例化Bean</strong>，装配好Bean之间的依赖关系，为上层业务提供基础的运行环境。</li></ol><p>其中Bean缓存池为HashMap实现。Spring Bean的装配流程如图。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210224192524135.png" alt="Bean装配流程"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/19ea23b5b90d631f35d375e20448a519.png" alt="具体流程"></p><h3 id="1-5-3-Bean作用域"><a href="#1-5-3-Bean作用域" class="headerlink" title="1.5.3 Bean作用域"></a>1.5.3 Bean作用域</h3><p>五种作用域，分别为：</p><ul><li>Singleton，单例</li><li>Prototype，原型</li><li>Request，请求级别</li><li>Session，会话级别</li><li>Global Session，全局</li></ul><p>作用域就是用来形容Bean容器中的一个Bean的作用范围。类似于public等修饰符。</p><h4 id="1-Singleton"><a href="#1-Singleton" class="headerlink" title="1. Singleton"></a>1. Singleton</h4><p>单例模式。IoC容器中，只会存在一个Bean对象，其他所有Bean引用的依赖都指向这一个Bean。</p><p>多线程下不安全。</p><p><strong>Spring中默认的就是Singleton作用域。</strong></p><h4 id="2-Prototype"><a href="#2-Prototype" class="headerlink" title="2. Prototype"></a>2. Prototype</h4><p>原型模式。</p><p><strong>每次通过Bean容器获取</strong>一个Prototype的Bean时，都会创建一个新的实例，每个Bean实例都有<strong>自己的属性和状态</strong>。</p><h4 id="3-Request"><a href="#3-Request" class="headerlink" title="3. Request"></a>3. Request</h4><p>HTTP请求范围。</p><p><strong>一次HTTP请求</strong>中是同一个Bean，而不同的HTTP请求则是不同的Bean。</p><p>当前请求结束后，这个Bean也会被销毁。</p><h4 id="4-Session"><a href="#4-Session" class="headerlink" title="4. Session"></a>4. Session</h4><p><strong>一次HTTP Session中</strong>是同一个Bean，仅在当前Session中有效。</p><p>不共享数据，Session结束后销毁。</p><h4 id="5-Global-Session"><a href="#5-Global-Session" class="headerlink" title="5. Global Session"></a>5. Global Session</h4><p><strong>全局的HTTP Session中</strong>返回同一个Bean。</p><p>尽在使用Porlet Context时有效。</p><blockquote><p><a href="https://blog.csdn.net/jimsonhappy/article/details/54707694">Connection连接与Session会话的理解</a></p><p>通俗来讲，会话(Session) 是通信双方从开始通信到通信结束期间的一个上下文（Context）。这个上下文是一段位于服务器端的内存：记录了本次连接的客户端机器、通过哪个应用程序、哪个用户登录等信息.</p><p>连接（Connection）：连接是从客户端到ORACLE实例的一条物理路径。连接可以在网络上建立，或者在本机通过IPC机制建立。通常会在客户端进程与一个专用服务器或一个调度器之间建立连接。</p><p>会话(Session) 是和连接(Connection)是同时建立的，两者是对同一件事情不同层次的描述。简单讲，连接(Connection)是物理上的客户端同服务器的通信链路，会话(Session)是逻辑上的用户同服务器的通信交互。</p></blockquote><h3 id="1-5-4-Bean生命周期"><a href="#1-5-4-Bean生命周期" class="headerlink" title="1.5.4 Bean生命周期"></a>1.5.4 Bean生命周期</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210224193041984.png" alt="SpringBean生命周期"></p><blockquote><p><a href="https://blog.csdn.net/riemann_/article/details/118500805">一文读懂 Spring Bean 的生命周期_riemann_的博客-CSDN博客</a></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210710134349143.png" alt="SpringBean生命周期2"></p><ul><li><p>Bean 自身的方法</p><p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p></li><li><p>容器级的方法（BeanPostProcessor 一系列接口）<br>主要是后处理器方法。比如 InstantiationAwareBeanPostProcessor、BeanPostProcessor 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p></li><li><p>Bean 级生命周期方法<br>可以理解为 Bean 类直接实现接口的方法，比如 BeanNameAware、BeanFactoryAware、ApplicationContextAware、InitializingBean、DisposableBean 等方法，这些方法只对当前 Bean 生效。</p></li></ul><p>三级方法是一级一级进行扩展的：</p><p>首先是最基本的Bean自身方法，进行最基本的创建：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210707002134280.png" alt="Bean自身方法"></p><p>之后是容器级处理方法，主要是后置处理方法，在各个阶段前后进行额外的处理：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210707225212729.png" alt="容器级方法扩展"></p><p>最后是Bean级方法，只对当前Bean生效，进行额外属性的赋值：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210710134349143.png" alt="SpringBean生命周期2"></p><hr><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/e8a473640bcd06e544c86fa729133ac3.png" alt="对应过程"></p><hr><p>日后需要去看看这个视频讲的不错：<a href="https://www.bilibili.com/video/BV1rt4y1v7HD?share_source=copy_web">Spring之Bean的生命周期详解_哔哩哔哩_bilibili</a></p><iframe src="//player.bilibili.com/player.html?aid=627385128&amp;bvid=BV1rt4y1v7HD&amp;cid=244295797&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></blockquote><h3 id="1-5-5-四种依赖注入"><a href="#1-5-5-四种依赖注入" class="headerlink" title="1.5.5 四种依赖注入"></a>1.5.5 四种依赖注入</h3><blockquote><p>这一块建议阅读<a href="https://www.zhihu.com/question/23277575/answer/169698662">Spring IoC有什么好处呢？ - 知乎 (zhihu.com)</a>，可以弄清楚到底为啥要用这四种注入方法。</p></blockquote><ul><li>构造器注入</li><li>set方法注入</li><li>静态工厂注入</li><li>实例工厂注入</li></ul><h4 id="1-构造器注入"><a href="#1-构造器注入" class="headerlink" title="1. 构造器注入"></a>1. 构造器注入</h4><p>构造器注入指通过在类的<strong>构造函数</strong>中注入属性或对象来实现依赖注入。</p><p>构造方法传入参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在构造函数中注入message属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersionDaoImpl</span><span class="params">(String message)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.message = message;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>xml配置文件：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义Bean实例并在构造函数constructor-arg中注入message属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"persionDaoImpl"</span> <span class="attr">class</span>=<span class="string">"com.PersionDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"message"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-set方法注入"><a href="#2-set方法注入" class="headerlink" title="2. set方法注入"></a>2. set方法注入</h4><p>set方法注入是通过在类中实现<strong>get、set方法</strong>来实现属性或对象的依赖注入的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">PersionDaoImpl</span><span class="params">(String message)</span></span>{</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//定义属性及其set get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>{<span class="keyword">return</span> id;}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{<span class="keyword">this</span>.id=id}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>xml配置文件</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义Bean实例并通过property注入id为123的属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"persionDaoImpl"</span> <span class="attr">class</span>=<span class="string">"com.PersionDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"123"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3-静态工厂注入"><a href="#3-静态工厂注入" class="headerlink" title="3. 静态工厂注入"></a>3. 静态工厂注入</h4><blockquote><p><a href="https://www.jianshu.com/p/ceb5ec8f1174">啥是静态工厂方法</a></p></blockquote><p>静态工厂注入是<strong>通过调用工厂类中定义的静态方法</strong>来获取需要的对象的。</p><p>为了让Spring管理所有对象，应用程序<strong>不能直接通过“工厂类.静态方法（）”的方式获取对象，而需要通过Spring注入（XML配置）的方式获取</strong>。代码如下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.定义静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title">getStaticFactoryDaoImpl</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> StaticFactoryDaoImpl();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> SpringAction{</span><br><span class="line"><span class="comment">//2.定义工厂对象</span></span><br><span class="line"><span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line"><span class="comment">//3.注入工厂对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaticFactoryDaoImpl</span><span class="params">(FactoryDao staticFactoryDao)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.staticFactoryDao = staticFactoryDao;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码定义了一个<code>DaoFactory</code>工厂类和<code>getStaticFactoryDaoImpl（）</code>静态工厂方法，该方法实例化并返回一个<code>StaticFactoryDaoImpl</code>实例；<br>同时定义了一个SpringAction类，并通过<code>setStaticFactoryDao</code>获取注入的<code>FactoryDao</code>。</p><p>具体的XML注入语法如下。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.定义获取工厂对象的静态方法--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--factory-method用于指定调用哪个工厂方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"staticFactoryDao"</span> <span class="attr">class</span>=<span class="string">"DaoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getStaticFactoryDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.注入静态工厂实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">"SpringAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"StaticFactoryDao"</span> <span class="attr">ref</span>=<span class="string">"staticFactoryDao"</span>&gt;</span>&lt;/property &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码中，第一个bean用来获取工厂及工厂方法，第二个bean用来实际注入。</p><h4 id="4-实例工厂注入"><a href="#4-实例工厂注入" class="headerlink" title="4. 实例工厂注入"></a>4. 实例工厂注入</h4><p>实例工厂注入指的是<strong>获取对象实例的方法是非静态的</strong>，因此首先需要实例化一个工厂类对象，然后调用对象的实例化方法来实例化对象。具体代码如下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span></span>{ <span class="comment">//1.实例工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FactoryDao <span class="title">getStaticFactoryDaoImpl</span><span class="params">()</span></span>{  <span class="comment">//工厂方法不是静态的</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FactoryDaoImpl();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> SpringAction{</span><br><span class="line"><span class="keyword">private</span> FactoryDao factoryDao; <span class="comment">//2.注入对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryDaoImpl</span><span class="params">(FactoryDao factoryDao)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.factoryDao= factoryDao;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"springAction"</span> <span class="attr">class</span>=<span class="string">"SpringAction"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1.使用实例工厂的方式注入对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ref属性是写的下面的beanName--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"factoryDao"</span> <span class="attr">ref</span>=<span class="string">"factoryDao"</span>&gt;</span>&lt;/property &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2.获取对象的方式是从工厂类中获取实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"daoFactory"</span> <span class="attr">class</span>=<span class="string">"com.DaoFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--先实例化工厂类，再从工厂对象中调用工厂方法得到对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"factoryDao"</span> <span class="attr">factory-bean</span>=<span class="string">"daoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getFactoryDaoImple"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码定义了一个name为factoryDao的工厂类，并通过factory-method定义了实例化对象的方法，这里实例化对象的方法是一个名为getFactoryDaoImpl的方法。该方法返回一个工厂类，在springAction中通过标签注入工厂实例。</p><h3 id="1-5-6-自动装配的5种方式"><a href="#1-5-6-自动装配的5种方式" class="headerlink" title="1.5.6 自动装配的5种方式"></a>1.5.6 自动装配的5种方式</h3><ul><li>手动装配<ul><li>基于XML配置</li><li>基于注解</li></ul></li><li>自动装配<ol><li>no：不启用自动装配，通过显式设置ref属性来进行对象装配。</li><li>byName：通过<strong>参数名</strong>自动装配，<strong>Bean的autowire</strong>被设置为byName后，Spring容器试图匹配并装配与该Bean的属性具有相同名字的Bean。</li><li>byType：通过<strong>参数类型</strong>自动装配，<strong>Bean的autowire</strong>被设置为byType后，Spring容器试图匹配并装配与该Bean的属性具有相同类型的Bean。</li><li>constructor：通过设置<strong>构造器参数</strong>的方式来装配对象，如果没有匹配到带参数的构造器参数类型，则Spring会抛出异常。</li><li>autodetect：<strong>首先尝试</strong>使用constructor来自动装配，如果<strong>无法完成</strong>自动装配，则使用byType方式进行装配。</li></ol></li></ul><h2 id="1-6-Spring-AOP原理"><a href="#1-6-Spring-AOP原理" class="headerlink" title="1.6 Spring AOP原理"></a>1.6 Spring AOP原理</h2><h3 id="1-6-1-AOP简介"><a href="#1-6-1-AOP简介" class="headerlink" title="1.6.1 AOP简介"></a>1.6.1 AOP简介</h3><p>AOP，面向切面编程。将公共的与核心业务无关的部分提取出来，<strong>提高代码复用率，降低耦合度。</strong></p><ul><li>核心关注点：业务核心</li><li>横切关注点：公共部分，比如日志、事务、权限认证。</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301175351325.png" alt="AOP常见应用场景"></p><h3 id="1-6-2-AOP核心概念"><a href="#1-6-2-AOP核心概念" class="headerlink" title="1.6.2 AOP核心概念"></a>1.6.2 AOP核心概念</h3><ul><li>切面，Aspect：切面类，在这里面写抽取的额外公共逻辑。</li><li>连接点，<strong>JoinPoint</strong>：被拦截的方法，也就是原方法，需要在这前面或者后面执行公共逻辑。</li><li>切入点，<strong>Pointcut</strong>：切面中的某个方法，在这前面或者后面执行公共逻辑。@Pointcut注解写切点表达式后跟一个函数，代表原来的方法。</li><li>通知，<strong>Advice</strong>：也就是公共逻辑执行的位置，对应Before、After那几个注解。前置通知，后置通知，成功通知，异常通知，环绕通知五类。</li><li>目标对象：原来的对象，也就是代理的目标对象。</li><li>织入，<strong>weaving</strong> ：将<strong>切面应用</strong>到目标对象并<strong>执行代理对象创建</strong>的过程。</li></ul><p>这些观念可以结合下面的具体例子来看。</p><blockquote><h4 id="具体例子：Spring-AOP-SpringBoot集成-柠檬五个半-博客园-cnblogs-com"><a href="#具体例子：Spring-AOP-SpringBoot集成-柠檬五个半-博客园-cnblogs-com" class="headerlink" title="具体例子：Spring AOP SpringBoot集成 - 柠檬五个半 - 博客园 (cnblogs.com)"></a>具体例子：<a href="https://www.cnblogs.com/LemonFive/p/10983875.html">Spring AOP SpringBoot集成 - 柠檬五个半 - 博客园 (cnblogs.com)</a></h4><p>1.编写业务类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.aop;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@desc</span>: 核心业务模块</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: CSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/aopController")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopController</span> </span>{</span><br><span class="line">    <span class="meta">@RequestMapping(value = "/Curry")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Curry</span><span class="params">()</span></span>{ System.out.println(<span class="string">"库里上场打球了！！"</span>); }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(value = "/Harden")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Harden</span><span class="params">()</span></span>{ System.out.println(<span class="string">"哈登上场打球了！！"</span>); }</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(value = "/Durant/{point}")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Durant</span><span class="params">(<span class="meta">@PathVariable("point")</span>  <span class="keyword">int</span> point)</span></span>{ System.out.println(<span class="string">"杜兰特上场打球了！！"</span>); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2.定义切面类：在类上添加@Aspect 和@Component 注解即可将一个类定义为切面类。 </p><ul><li><code>@Aspect</code> 注解 使之成为切面类</li><li><code>@Component</code> 注解 把切面类加入到IOC容器中</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.aop;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@desc</span>: 经纪人切面</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: CSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerAspect</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点，切入点为com.example.demo.aop.AopController中的所有函数</span></span><br><span class="line"><span class="comment">     *通过<span class="doctag">@Pointcut</span>注解声明频繁使用的切点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut("execution(public * com.example.demo.aop.AopController.*(..)))</span><span class="string">")</span></span><br><span class="line"><span class="string">    public void BrokerAspect(){}</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    /** * @description  在连接点执行之前执行的通知 */</span></span><br><span class="line"><span class="string">    @Before("</span>BrokerAspect()<span class="string">")</span></span><br><span class="line"><span class="string">    public void doBeforeGame(){</span></span><br><span class="line"><span class="string">        System.out.println("</span>经纪人正在处理球星赛前事务！<span class="string">");</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    /** * @description  在连接点执行之后执行的通知（返回通知和异常通知的异常） */</span></span><br><span class="line"><span class="string">    @After("</span>BrokerAspect()<span class="string">")</span></span><br><span class="line"><span class="string">    public void doAfterGame(){ System.out.println("</span>经纪人为球星表现疯狂鼓掌！<span class="string">"); }</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    /** * @description  在连接点执行之后执行的通知（返回通知） */</span></span><br><span class="line"><span class="string">    @AfterReturning("</span>BrokerAspect()<span class="string">")</span></span><br><span class="line"><span class="string">    public void doAfterReturningGame(){ System.out.println("</span>返回通知：经纪人为球星表现疯狂鼓掌！<span class="string">"); }</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    /** * @description  在连接点执行之后执行的通知（异常通知） */</span></span><br><span class="line"><span class="string">    @AfterThrowing("</span>BrokerAspect()<span class="string">")</span></span><br><span class="line"><span class="string">    public void doAfterThrowingGame(){ System.out.println("</span>异常通知：球迷要求退票！<span class="string">"); }</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>@Pointcut("execution(public * com.example.demo.aop.AopController.*(..)))")</code> ，AOP切点表达式，表示要在哪里切入（在这个方法前后执行切入的函数）<br><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210804170414308.png" alt="切点表达式"></li><li>@Before(“BrokerAspect()”) ：其中的函数名是 <code>@Pointcut</code> 注解之中的，也就是切点之前执行。</li><li>@After：在连接点执行之后执行的通知（返回通知和异常通知的异常）</li><li>@AfterReturning：在连接点执行之后执行的通知（返回通知）</li><li>@AfterThrowing：在连接点执行之后执行的通知（异常通知）</li></ul><p><strong>可以看到，原业务类无任何更改，只是新写了这么一个Aspect类，就做到了在原方法之前或者之后执行额外方法。所以说做到了低耦合</strong></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210804172435852.png" alt="输出结果"></p><p>最后，Around注解可以在方法前和后执行：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * <span class="doctag">@description</span>  使用环绕通知 */</span></span><br><span class="line"><span class="meta">@Around("BrokerAspect()")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAroundGame</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        System.out.println(<span class="string">"经纪人正在处理球星赛前事务！"</span>);</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"返回通知：经纪人为球星表现疯狂鼓掌！"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span>(Throwable e){</span><br><span class="line">        System.out.println(<span class="string">"异常通知：球迷要求退票！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里主要是<code>ProceedingJoinPoint pjp</code>这个参数，表示切入点的方法。</p><p><code>pjp.proceed();</code>就表示执行原方法，在这一行的前后进行切面逻辑的编写即可。</p><p>以及，带参数的方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.aop;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@desc</span>:技术统计</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: CSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameDataAspect</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点，切入点为com.example.demo.aop.AopController中的所有函数</span></span><br><span class="line"><span class="comment">     *通过<span class="doctag">@Pointcut</span>注解声明频繁使用的切点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut("execution(public * com.example.demo.aop.AopController.Durant(int)) &amp;&amp; args(point))</span><span class="string">")</span></span><br><span class="line"><span class="string">    public void GameDataAspect(int point){ }</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    /** * @description  使用环绕通知 */</span></span><br><span class="line"><span class="string">    @Around("</span>GameDataAspect(point)<span class="string">")</span></span><br><span class="line"><span class="string">    public void doAroundGameData(ProceedingJoinPoint pjp,int point) throws Throwable {</span></span><br><span class="line"><span class="string">        try{</span></span><br><span class="line"><span class="string">            System.out.println("</span>球星上场前热身！<span class="string">");</span></span><br><span class="line"><span class="string">            pjp.proceed();</span></span><br><span class="line"><span class="string">            System.out.println("</span>球星本场得到<span class="string">" + point + "</span>分<span class="string">" );</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">        catch(Throwable e){</span></span><br><span class="line"><span class="string">            System.out.println("</span>异常通知：球迷要求退票！<span class="string">");</span></span><br><span class="line"><span class="string">        }</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>修改切点表达式，传入参数即可。</p></blockquote><h3 id="1-6-3-AOP代理的两种方式"><a href="#1-6-3-AOP代理的两种方式" class="headerlink" title="1.6.3 AOP代理的两种方式"></a>1.6.3 AOP代理的两种方式</h3><p>两种方式：CGLib动态代理和JDK动态代理。</p><p>Spring默认的策略：</p><ul><li>如果是目标类接口，使用JDK动态代理；</li><li>否则使用CGLib动态代理。</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/NXZp8a3n-ssnC6Y1Hy9lzw">漫画:AOP 面试造火箭事件始末 (qq.com)</a></p><p>代理模式。</p><p>代理分为静态代理和动态代理：</p><ul><li>静态代理：就是我们自己手写的，在<strong>编译前定义好</strong>代理类/接口。</li><li>动态代理：通过<strong>JDK反射机制</strong>在<strong>程序运行后创建</strong></li></ul><p>动态代理又分为JDK代理和CGLib代理：</p><ul><li>JDK动态代理：委托类（原来的目标类）必须<strong>实现接口</strong>，代理类和委托类实现同样的接口，然后代理类对其增强。</li><li>CGLib动态代理：委托类不需要实现接口，而是代理类来<strong>继承委托类</strong>。</li></ul><p>底层源码就先不深挖了。。。</p><ul><li><p>JDK动态代理通过<strong>反射机制</strong>来实现，有一定的性能问题。</p></li><li><p>CGLib性能稍高，是通过一个叫<strong>FastClass的机制</strong>来实现的，简单来说就是对类中的方法进行一个索引。</p></li></ul><p>CGLib不能代理 <strong>final 的方法\类</strong>，因为final修饰不能被继承/重写。</p></blockquote><h3 id="1-6-4-AOP的5种通知类型"><a href="#1-6-4-AOP的5种通知类型" class="headerlink" title="1.6.4 AOP的5种通知类型"></a>1.6.4 AOP的5种通知类型</h3><p>也就是Advice，那几个位置。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301175940812.png" alt="AOP五种通知类型"></p><h3 id="1-6-5-AOP的代码实例"><a href="#1-6-5-AOP的代码实例" class="headerlink" title="1.6.5 AOP的代码实例"></a>1.6.5 AOP的代码实例</h3><p>（上面已经举过例子了）</p><p>在Spring中，AOP的使用比较简单，如下代码通过@Aspect注解声明一个切面，通过@Pointcut定义需要拦截的方法，然后用@Before、@AfterReturning、@Around分别实现前置通知、后置通知和环绕通知要执行的方法。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301180042561.png" alt="AOP实例"></p><h2 id="1-7-Spring-MVC原理"><a href="#1-7-Spring-MVC原理" class="headerlink" title="1.7 Spring MVC原理"></a>1.7 Spring MVC原理</h2><p>MVC，模型-视图-控制器。</p><p>围绕一个DispatcherServlet，分发请求。</p><p><img src="https://img-blog.csdnimg.cn/20210301180234481.png" alt="SpringMVC流程"></p><h2 id="1-8-事务"><a href="#1-8-事务" class="headerlink" title="1.8 事务"></a>1.8 事务</h2><p>事务的特性：ACID，原子性，一致性，隔离性，持久性。</p><h3 id="1-8-1-本地事务"><a href="#1-8-1-本地事务" class="headerlink" title="1.8.1 本地事务"></a>1.8.1 本地事务</h3><p>JDBC的本地事务：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301181354691.png" alt="img"></p><h3 id="1-8-2-分布式事务"><a href="#1-8-2-分布式事务" class="headerlink" title="1.8.2 分布式事务"></a>1.8.2 分布式事务</h3><p>跨数据库，分布式事务操作</p><ul><li>跨数据库<ul><li>同一类型数据库，多个数据源</li><li>不同数据库</li></ul></li></ul><p>Java事务编程接口JTA，和Java事务服务JTS，提供了分布式事务服务。</p><ul><li>事务管理器：负责所有事务参与单元的协调与控制。</li><li>XA协议的资源管理器：XA协议定义了事务管理器与资源管理器之间的接口；资源管理器负责不同数据库具体的事务执行操作。</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301182140598.png" alt="UserTransaction操作两个数据库"></p><h3 id="1-8-3-两阶段提交协议"><a href="#1-8-3-两阶段提交协议" class="headerlink" title="1.8.3 两阶段提交协议"></a>1.8.3 两阶段提交协议</h3><p>二阶段提交协议，Two-phase Commit，简写为2PC。一般也称为XA方案。</p><p><strong>两阶段提交协议用于保证分布式事务的原子性。 即所有数据库，要么都执行要么都不执行。</strong></p><p><strong>两个阶段：1.准备阶段；2.提交阶段。</strong></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/20210301182735105.png" alt="两个阶段"></p><p>我们需要引入一个<strong>协调者来管理所有的节点</strong>，负责各个本地资源的提交和回滚，并确保这些节点正确提交操作结果，若提交失败则放弃事务。</p><p>这里事务管理器是指事务协调者，资源管理器是事务参与者。</p><ol><li><p>准备阶段</p><ol><li><p>为每个参与者都发送Prepare消息。</p></li><li><p>返回消息</p><ul><li><p>返回失败（例如权限验证不通过）</p></li><li><p>返回成功：每个参与者在本地执行事务，写本地的undo和redo日志，但不提交，返回成功消息。</p></li></ul></li><li><p>等所有参与者都返回结果之后，进入提交阶段。</p></li></ol></li><li><p>提交阶段</p><ol><li>所有的都OK了，那么就提交；</li><li>只要有一个不OK或者超时的，就给全部参与者发送回滚消息。</li></ol></li></ol><p>事务的执行和释放是<strong>在JPA中基于锁</strong>来实现控制的。</p><blockquote><p><a href="https://www.jianshu.com/p/1aa944f44b7b">分布式事务理论-二阶段提交（Two-phase Commit） - 简书 (jianshu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/35616810">分布式一致性之两阶段提交协议、三阶提交协议 - 知乎 (zhihu.com)</a></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/9793627-a71a27fddfabfa2b.png" alt="2PC"></p><p>同样还有改进的3PC，三阶段提交协议。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/9793627-f90ffe49d3ce34a9.png" alt="三阶段提交协议"></p><p>优缺点总结。</p><ul><li><p>数据不一致问题：</p><ul><li>只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。</li><li>协调者再发出DoCommit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ul></li><li><p>同步阻塞问题：当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。</p></li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/9793627-f61ad7165e8ac269.jpg" alt="优缺点"></p></blockquote><p>==严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。==</p><p>在微服务中，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。每个服务只能连自己的库。操作别人的库，必须通过别的服务来接口调用，不能直接操作。</p><h2 id="1-9-Mybatis缓存"><a href="#1-9-Mybatis缓存" class="headerlink" title="1.9 Mybatis缓存"></a>1.9 Mybatis缓存</h2><blockquote><p><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制 - 美团技术团队 (meituan.com)</a><br>美团技术团队NB</p></blockquote><p>MyBatis缓存分为<strong>一级缓存和二级缓存</strong>。 </p><p>一级缓存默认开启，而且是不能被关闭的。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/2021030118292044.png" alt="Mybatis两级缓存"></p><h3 id="1-9-1-一级缓存"><a href="#1-9-1-一级缓存" class="headerlink" title="1.9.1 一级缓存"></a>1.9.1 一级缓存</h3><p><strong>缓存到SqlSession中。</strong></p><p>缓存的<strong>数据结构是用的Map</strong>，key为MapperId + Offset + Limit + SQL +所有入参。</p><p>如果相同SQL的两次查询中间出现了Commit操作（增删改），则会清空SqlSession一级缓存，再重新查询进行缓存。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/6e38df6a.jpg" alt="一级缓存"></p><p>每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。</p><h4 id="一级缓存总结"><a href="#一级缓存总结" class="headerlink" title="一级缓存总结"></a>一级缓存总结</h4><ol><li>MyBatis一级缓存的<strong>生命周期和SqlSession一致</strong>。</li><li>MyBatis一级缓存内部设计简单，<strong>只是一个没有容量限定的HashMap</strong>，在缓存的功能性上有所欠缺。</li><li>MyBatis的一级缓存最大范围是SqlSession内部，<strong>有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。</strong></li></ol><h3 id="1-9-2-二级缓存"><a href="#1-9-2-二级缓存" class="headerlink" title="1.9.2 二级缓存"></a>1.9.2 二级缓存</h3><blockquote><p> 简单来说，二级缓存就是全局变量，一级缓存就是局部变量；不过这里是先全局后局部的。</p></blockquote><p>二级缓存是可以跨SqlSession的，多个SqlSession共享一个缓存。</p><p>进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/28399eba.png" alt="img"></p><h4 id="二级缓存总结"><a href="#二级缓存总结" class="headerlink" title="二级缓存总结"></a>二级缓存总结</h4><ol><li>MyBatis的二级缓存相对于一级缓存来说，实现了 ** <code>SqlSession</code>之间缓存数据的共享 **，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis<strong>在多表查询时，极大可能会出现脏数据</strong>，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li><li>在分布式环境下，由于<strong>默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据</strong>，需要<strong>使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本</strong>，==直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。==</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring原理及应用&quot;&gt;&lt;a href=&quot;#Spring原理及应用&quot; class=&quot;headerlink&quot; title=&quot;Spring原理及应用&quot;&gt;&lt;/a&gt;Spring原理及应用&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;1-1-Spring特性&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Spring" scheme="https://songx64.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java常见线程池</title>
    <link href="https://songx64.github.io/2021/07/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A02/"/>
    <id>https://songx64.github.io/2021/07/24/Java%E7%BA%BF%E7%A8%8B%E6%B1%A02/</id>
    <published>2021-07-24T08:41:01.000Z</published>
    <updated>2021-07-24T13:55:12.731Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程池创建"><a href="#Java线程池创建" class="headerlink" title="Java线程池创建"></a>Java线程池创建</h1><h2 id="0-回顾"><a href="#0-回顾" class="headerlink" title="0.回顾"></a>0.回顾</h2><p>之前一篇讲的比较乱，主要整理自别人的。这次自己记一下想要说的问题。</p><p>想要理解的就是，常用线程池，手动创建线程池，关于核心线程和工作线程。</p><p>以及补充一下阻塞队列，还有拒绝策略。</p><h2 id="1-常用线程池"><a href="#1-常用线程池" class="headerlink" title="1.常用线程池"></a>1.常用线程池</h2><ul><li><code>newCachedThreadPool</code> ：<strong>Cached，可缓存线程池</strong>，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li><code>newFixedThreadPool</code> ：<strong>Fixed，定长线程池</strong>，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><code>newSceduledThreadPool</code> ：<strong>Scheduled，定长线程池</strong>，支持定时及周期性任务执行。</li><li><code>newSingleThreadExecutor</code> ：<strong>Single，单线程化的线程池</strong>，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><h2 id="2-详细参数"><a href="#2-详细参数" class="headerlink" title="2.详细参数"></a>2.详细参数</h2><p>其实主要就是看一下他们的创建方式。</p><h3 id="2-0-手动创建线程池"><a href="#2-0-手动创建线程池" class="headerlink" title="2.0 手动创建线程池"></a>2.0 手动创建线程池</h3><p>首先回忆一下手动创建线程池的重要参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                           )</span></span></span><br></pre></td></tr></tbody></table></figure><ul><li>核心线程数</li><li>最大线程数</li><li>存活时间，时间单位</li><li>阻塞队列</li><li>线程工厂（可忽略）：用来设置<strong>线程名字</strong>的，默认为 <code>pool-线程池数-thread-线程数</code></li><li>拒绝策略（可忽略）：默认拒绝策略为<code>AbortPolicy</code>，即 <strong>丢弃任务并抛出异常</strong> <code>RejectedExecutionException</code></li></ul><hr><h4 id="2-0-1-拒绝策略"><a href="#2-0-1-拒绝策略" class="headerlink" title="2.0.1 拒绝策略"></a>2.0.1 拒绝策略</h4><p>拒绝策略有四种，简单提一下：</p><ol><li><p><code>AbortPolicy</code> ：丢弃任务，<strong>抛出异常</strong></p></li><li><p><code>DiscardPolicy</code> ：丢弃任务，<strong>静默</strong>丢弃</p></li><li><p><code>DiscardOledestPolicy</code> ：<strong>丢弃队列中最老的未处理请求</strong>，然后再次尝试提交新任务。</p></li><li><p><code>CallerRunsPolicy</code> ：在调用者线程中，运行当前被丢弃的任务。</p></li></ol><p>也就是说，两个丢弃当前任务（不管新任务）；<br>一个丢弃队列中最老任务（新任务重要老任务可以不管）；<br>一个让别人执行任务（调用当前线程的线程）；</p><h4 id="2-0-2-阻塞队列"><a href="#2-0-2-阻塞队列" class="headerlink" title="2.0.2 阻塞队列"></a>2.0.2 阻塞队列</h4><p>阻塞队列中的<strong>有界无界</strong>就是说最大存储容量，但是是理想的。无界一般都是指 <code>Integer.MAX_VALUE</code> ，int的最大值个数。有界就是自己来指定容量。</p><h5 id="1-SynchronousQueue"><a href="#1-SynchronousQueue" class="headerlink" title="1.SynchronousQueue"></a>1.SynchronousQueue</h5><p><code>SynchronousQueue</code> 是一个<strong>没有数据缓冲</strong>的同步队列，不存储元素。</p><p>每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>常用于<strong>生产者消费者</strong>问题，负责把生产者线程处理的数据直接传递给消费者线程。</p><h5 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2. LinkedBlockingQueue"></a>2. LinkedBlockingQueue</h5><p><code>LinkedBlockingQueue</code> ，基于链表（linked nodes）的可选界（optionally-bounded）的双向阻塞队列，线程安全。</p><p>可以对first、last元素进行操作，两端都可以入队出队。</p><p>默认容量为 <code>Integer.MAX_VALUE</code> ，无界队列。</p><h5 id="3-DelayedWorkQueue"><a href="#3-DelayedWorkQueue" class="headerlink" title="3.DelayedWorkQueue"></a>3.DelayedWorkQueue</h5><p><code>DelayedWorkQueue</code> ，一个定制的专门用于存储Runnable任务的队列。</p><p>优先级队列，基于堆结构的等待队列，最小堆。</p><p>最近要到达时间的节点放在堆顶，每个节点都会附带到期时间，依次作为堆调整的依据。</p><h3 id="2-1-Cached"><a href="#2-1-Cached" class="headerlink" title="2.1 Cached"></a>2.1 Cached</h3><p>Cached，缓存的；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析一下其参数：</p><ul><li>核心线程：0个，也就是说</li><li>最大线程数：Integer的最大值，反正也是很多了</li><li>存活时间、单位：60秒</li><li>阻塞队列：<code>SynchronousQueue</code> ,同步队列，无容量</li></ul><p>这样的话，其关键在于<strong>核心线程0个</strong>和这个<strong>同步队列</strong>。</p><p>来一个线程就创建一个非核心线程，因为队列中不存储任何元素。</p><p>用完1分钟后销毁，所以说是Cached缓存一下。</p><h3 id="2-2-Fixed"><a href="#2-2-Fixed" class="headerlink" title="2.2 Fixed"></a>2.2 Fixed</h3><p>Fixed，固定的（固定数量的）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li>核心线程：传入的n</li><li>最大线程：传入的n</li><li>存活时间、单位：0毫秒</li><li>阻塞队列：<code>LindedBlockingQueue</code> ，链表双向阻塞队列</li></ul><p>这个的关键是在 <code>核心线程数==最大线程数</code> ，所有的线程都是核心线程，不会销毁。</p><p>然后不考虑Integer最大值的话，是无界的，也就是说<strong>使用核心线程去处理所有任务</strong>。</p><p>其中的线程数是固定的不会销毁的，所以说是Fixed。</p><h3 id="2-3-Scheduled"><a href="#2-3-Scheduled" class="headerlink" title="2.3 Scheduled"></a>2.3 Scheduled</h3><p>Scheduled，预定的；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li>核心线程：传入的c</li><li>最大线程：Integer最大值</li><li>存活时间、单位：0纳秒</li><li>阻塞队列： <code>DelayedWorkQueue</code> ，延迟队列，小根堆。</li></ul><p>其关键在于这个队列，<strong>优先级队列小根堆</strong>。</p><p>这是一个可以<strong>定时、周期性执行的线程池</strong>，它继承<code>FutureTask</code>并实现了接口<code>RunnableScheduledFuture</code>。</p><p>里面有个参数time，指的是执行时间。有个函数<code>setNextRunTime()</code>，可以设置下次执行时间。</p><p><strong>小根堆的优先级就是根据时间来排序的。</strong></p><h3 id="2-4-Single"><a href="#2-4-Single" class="headerlink" title="2.4 Single"></a>2.4 Single</h3><p>Single，单例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参数：</p><ul><li>核心线程：1</li><li>最大线程：1</li><li>存活时间、单位：0毫秒</li><li>阻塞队列：<code>LinkedBlockingQueue</code> </li></ul><p>其关键在于，核心线程和最大线程都是1。</p><p>而且是无界队列，也就是说<strong>只有一个线程存活并执行</strong>。其他任务都排队。</p><p>所以说是Single。</p><h2 id="3-补充"><a href="#3-补充" class="headerlink" title="3. 补充"></a>3. 补充</h2><p>有一点比较重要的，之前一直理解错了。。。</p><p>也就是说线程池中的<strong>核心线程，和非核心线程，并没有什么区别，他们都是普通线程，并没有什么参数来区分他们。</strong></p><p>在回收线程非核心线程的时候，看谁闲着并且超过存活时间了，就去回收它。</p><p>啊，就这样吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java线程池创建&quot;&gt;&lt;a href=&quot;#Java线程池创建&quot; class=&quot;headerlink&quot; title=&quot;Java线程池创建&quot;&gt;&lt;/a&gt;Java线程池创建&lt;/h1&gt;&lt;h2 id=&quot;0-回顾&quot;&gt;&lt;a href=&quot;#0-回顾&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="多线程" scheme="https://songx64.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>什么是数据库中的MVCC</title>
    <link href="https://songx64.github.io/2021/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93MVVC/"/>
    <id>https://songx64.github.io/2021/07/01/%E6%95%B0%E6%8D%AE%E5%BA%93MVVC/</id>
    <published>2021-07-01T09:33:00.000Z</published>
    <updated>2021-08-08T11:04:52.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脏读、幻读是什么，MVCC"><a href="#脏读、幻读是什么，MVCC" class="headerlink" title="脏读、幻读是什么，MVCC?"></a>脏读、幻读是什么，MVCC?</h1><h2 id="脏读-幻读"><a href="#脏读-幻读" class="headerlink" title="脏读/幻读"></a>脏读/幻读</h2><p>答：脏读，是指读到了脏数据，比方说一个事务A，执行了修改了个数据，但是还没有提交；这时候事务B来读取到了事务A修改后的这个数据，然后A发生错误回滚了，这时候这个事务B的那个数据就是脏数据。</p><p>幻读是指对表的数据，比方说插入了几条数据，这时候另一个事务来了读取了这几条数据，然后这几条数据又回滚或者删除了，另一个事务读到的数据就好像是幻影好像不存在。(不对)</p><blockquote><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210701113829078.png" alt="三种数据不一致"></p><p>幻读就是你一个事务用一样的 SQL 多次查询，结果每次查询都会发现查到一些之前没看到过的数据。注意，<strong>幻读特指的是你查询到了之前查询没看到过的数据。此时说明你是幻读了</strong></p></blockquote><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><blockquote><p><a href="https://www.zhihu.com/question/27876575">乐观锁和 MVCC 的区别？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/shujiying/p/11347632.html">Mysql中MVCC的使用及原理详解 - 开顺 - 博客园 (cnblogs.com)</a></p></blockquote><p>当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：</p><ol><li>读-读，不存在任何问题</li><li>读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。</li><li>写-写，可能丢失更新</li></ol><p>多版本并发控制（MVCC）是一种用来 <strong>解决读-写冲突</strong> 的无锁并发控制，<br>也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，<br><strong>读操作只读该事务开始前的数据库的快照</strong>。 </p><p>这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了<strong>脏读和不可重复读</strong></p><p>（简单回顾，脏读是读到未提交事务的数据，不可重复读是两次读数据之间另一个事务修改了此数据）</p><h3 id="MVCC实现：版本链-ReadView"><a href="#MVCC实现：版本链-ReadView" class="headerlink" title="MVCC实现：版本链 + ReadView"></a><strong>MVCC实现：版本链 + ReadView</strong></h3><ul><li>版本链：由两个隐藏列实现， <code>trx_id</code> 和 <code>roll_pointer</code> <ul><li>trx_id ： 对此行数据执行操作的<strong>事务ID</strong>（事务ID是不断增长的一个ID）</li><li>roll_pointer ：一个<strong>回滚指针</strong>。每条数据修改时，<u>老版本会存在 Undo 日志中</u>。这个 roll_pointer 就是指向当前数据的老版本的位置。</li></ul></li><li>ReadView：存储当前<strong>正在执行</strong>的事务ID，也就是还<strong>未提交</strong>的事务的ID</li></ul><p>读数据过程：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前数据的最新trx_id</span></span><br><span class="line">TrxId currentRowTrxId = table.getRow().getTrxId();</span><br><span class="line"><span class="comment">// 如果trx_id &lt; readView中的所有 trx_id</span></span><br><span class="line"><span class="comment">// 表明这条数据的修改事务已经完成，当前正在执行的事务可以直接访问它</span></span><br><span class="line"><span class="comment">// 避免了脏读</span></span><br><span class="line"><span class="keyword">if</span>(currentRowTrxId &lt; readview.allId()){</span><br><span class="line">访问;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">    <span class="comment">// 表示当前数据的修改，是当前事务的后面的新事务修改</span></span><br><span class="line">    <span class="comment">// 这时候当前事务读到的是老的数据</span></span><br><span class="line">    RollPointer rollpointer = table.getRow().getRollPointer();</span><br><span class="line">    <span class="comment">// 读取上N个版本的</span></span><br><span class="line">    <span class="keyword">while</span>(TrxId &gt;= readView[rollPointer]){</span><br><span class="line">        rollPointer = rollPointer.getRow().getRollPointer();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>举例：</p><ul><li>当前行数据 row 的 trx_id == 10，正在执行的事务T要来读取这个row<ul><li>正在执行事务 T_ID = 11，那么 readView == [11]；<br>判断 row_trx_id 与 readView_ID : 10 &lt; 11 ；<br>说明 row 这个数据修改的已经是在事务11之前完成，可以读取最新的row。</li><li>正在执行的当前事务T_ID == 9，那么readView == [9]；<br>判断 row_trx_id 与 readView_ID : 9 &lt; 10；<br>9不能读取row最新的，而是去读取上一个版本的（或者上N个版本的）。</li></ul></li></ul><p>总结：</p><ul><li>解决了读-写的问题，避免了脏读和不可重复读</li><li>通过版本链 + ReadView实现</li><li>版本链通过 隐藏行（trx_id 和 roll_pointer) 和 Undo 日志实现<ul><li>row_trx_id &lt; T_ID (ReadView_ID)：当前行为最新，可以读取</li><li>否则，去Undo日志中读取旧版本</li></ul></li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210702105224849.png" alt="举例"></p><h3 id="注意：InnoDB中的MVCC"><a href="#注意：InnoDB中的MVCC" class="headerlink" title="注意：InnoDB中的MVCC"></a>注意：InnoDB中的MVCC</h3><p>在MySQL的InnoDB引擎中，是由版本号，create_vesion，delete_version实现的。</p><blockquote><p><a href="https://www.cnblogs.com/shujiying/p/11347632.html">Mysql中MVCC的使用及原理详解 - 开顺 - 博客园 (cnblogs.com)</a></p><p>这里的版本号并不是实际的时间值，而是系统版本号。</p><p>每开始新的事务，系统版本号都会自动递增。</p><p>事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。</p><p>每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</p></blockquote><ol><li>插入：设定 <code>create_version</code> ；</li><li>删除：设定 <code>delete_version</code> ；</li><li>更新：新纪录设定 <code>craete_version</code>，旧记录保存并设定 <code>delete_version = current_version</code> ；</li><li>读取：比较当前版本号和 <code>create_version</code> 大小，然后根据 <code>delete_version</code> 去查找旧记录：<ol><li> <code>create_version</code>，保证当前事务所在的版本读取不到新的数据（即事务id为2的事务只能读取到create version&lt;=2的已提交的事务的数据集）</li><li> <code>delete_version</code>，保证当前事务读取的，在当前事务版本未被删除（即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行）</li></ol></li></ol><p><a href="https://www.cnblogs.com/liulvzhong/articles/9242299.html">MVCC简介 - 绿洲2017 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;脏读、幻读是什么，MVCC&quot;&gt;&lt;a href=&quot;#脏读、幻读是什么，MVCC&quot; class=&quot;headerlink&quot; title=&quot;脏读、幻读是什么，MVCC?&quot;&gt;&lt;/a&gt;脏读、幻读是什么，MVCC?&lt;/h1&gt;&lt;h2 id=&quot;脏读-幻读&quot;&gt;&lt;a href=&quot;#脏读</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="https://songx64.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Lamda表达式简单了解</title>
    <link href="https://songx64.github.io/2021/06/26/JavaKuangshenLamda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://songx64.github.io/2021/06/26/JavaKuangshenLamda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-06-26T03:03:05.000Z</published>
    <updated>2021-06-26T10:28:50.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1V4411p7EF?p=10">【狂神说Java】多线程详解_哔哩哔哩_bilibili</a></p></blockquote><h2 id="1-啥东西"><a href="#1-啥东西" class="headerlink" title="1.啥东西"></a>1.啥东西</h2><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623160203671.png" alt="Lamda表达式"></p><ul><li>为什么要使用lambda表达式<ul><li>避免匿名内部类定义过多</li><li>可以让你的代码看起来很简洁</li><li>去掉了一堆没有意义的代码，只留下核心的逻辑。</li></ul></li></ul><p>也许你会说，我看了Lambda表达式，不但不觉得简洁，反而觉得更乱，看不懂了。那是因为我们还没有习惯，用的多了，看习惯了，就好了。</p><h2 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h2><ul><li><p>理解Functional Interface(函数式接口)是学习Java8 lambda表达式的关键所在。</p></li><li><p>函数式接口的定义:<br>任何接口，如果<strong>只包含唯一一个抽象方法</strong>，那么它就是一个函数式接口。<br><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623160422715.png" alt="函数式接口"></p></li><li><p>对于函数式接口，我们可以<strong>通过lambda表达式来创建该接口的对象</strong>。</p></li></ul><h2 id="2-Lambda表达式优化过程"><a href="#2-Lambda表达式优化过程" class="headerlink" title="2.Lambda表达式优化过程"></a>2.Lambda表达式优化过程</h2><p>看代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ILike</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"2.普通的实现类"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>{</span><br><span class="line">    <span class="comment">// 3.静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"3.放在类内部的类，使用static"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 调用函数式接口的对象</span></span><br><span class="line">        ILike like1 = <span class="keyword">new</span> Like();</span><br><span class="line">        like1.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用3静态内部类</span></span><br><span class="line">        ILike like2 = <span class="keyword">new</span> Like2();</span><br><span class="line">        like2.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">ILike</span></span>{</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"4.局部内部类，放在main方法里面"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ILike like3 = <span class="keyword">new</span> Like3();</span><br><span class="line">        like3.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 匿名内部类，没有类名，必须借助接口或者父类</span></span><br><span class="line">        ILike like4 = <span class="keyword">new</span> ILike() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(<span class="string">"5.匿名内部类,不再需要类名，直接父类/接口的构造函数后面{}跟子类代码"</span>);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">        like4.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. Lambda简化，只留下函数的括号还有函数内部代码</span></span><br><span class="line">        ILike like5 = ()-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"6.Lambda简化后，不再需要构造方法名和函数名，根据变量类型来判断的。加个-&gt;"</span>);</span><br><span class="line">        };</span><br><span class="line">        like5.lambda();</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-带参数的-Lambda表达式"><a href="#3-带参数的-Lambda表达式" class="headerlink" title="3.带参数的 Lambda表达式"></a>3.带参数的 Lambda表达式</h3><p>看代码就行了</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Printer</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(String s)</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String a = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 带参数的Lambda实现</span></span><br><span class="line">        Printer printer1 = (String s)-&gt;{</span><br><span class="line">            System.out.println(<span class="string">"Lambda1 + "</span> + s);</span><br><span class="line">        };</span><br><span class="line">        printer1.myPrint(a);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简化1，去掉参数类型</span></span><br><span class="line">        Printer printer2 = (s)-&gt; {</span><br><span class="line">            System.out.println(<span class="string">"去参数类型： "</span>+s);</span><br><span class="line">        };</span><br><span class="line">        printer2.myPrint(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化2，去掉参数括号(只有一个参数的时候)</span></span><br><span class="line">        Printer printer3 = s-&gt; {</span><br><span class="line">            System.out.println(<span class="string">"去小括号： "</span>+s);</span><br><span class="line">        };</span><br><span class="line">        printer3.myPrint(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 简化3，去掉函数的大括号(只有一行的时候)</span></span><br><span class="line">        Printer printer4 = s-&gt; System.out.println(<span class="string">"一行的时候，去大括号： "</span>+s);</span><br><span class="line">        printer4.myPrint(a);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>多线程中的 Runnable 就是一个函数式接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lamda表达式&quot;&gt;&lt;a href=&quot;#Lamda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lamda表达式&quot;&gt;&lt;/a&gt;Lamda表达式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程实战学习笔记</title>
    <link href="https://songx64.github.io/2021/06/25/JavaKuangshen%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://songx64.github.io/2021/06/25/JavaKuangshen%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-25T04:03:05.000Z</published>
    <updated>2021-06-26T10:28:50.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程学习"><a href="#多线程学习" class="headerlink" title="多线程学习"></a>多线程学习</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1V4411p7EF">【狂神说Java】多线程详解_哔哩哔哩_bilibili</a></p></blockquote><p>这个只是简单的学了一下怎么用，几个小demo，没有深入的讲。</p><h2 id="1-线程简介"><a href="#1-线程简介" class="headerlink" title="1. 线程简介"></a>1. 线程简介</h2><p>线程，进程，多线程</p><ul><li>并发：同时发生，在一个时间段内执行，不一定是同一时间点</li><li>并行：同时执行，在一个时间点上有多个线程执行</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623091741197.png" alt="关于run()和start()"></p><ul><li>一个进程可以有多个线程</li></ul><h3 id="Process-和-Thread"><a href="#Process-和-Thread" class="headerlink" title="Process 和 Thread"></a>Process 和 Thread</h3><p>三个概念，程序、进程、线程：</p><ul><li>程序：静态代码</li><li>进程：程序的一次执行过程</li><li>线程：一个进程可以包含多个线程，<strong>线程是CPU调度和执行的单位</strong>。</li></ul><p>很多多线程是模拟出来的，真正的多线程是指有多个CPU。模拟的线程只是一个CPU切换的很快产生了多线程的错觉。其实就是并发和并行的区别。</p><h3 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h3><ul><li><code>main()</code> 函数就是主线程；</li><li>默认的话有主线程、GC线程等；</li><li>线程因为调度，会代来开销</li><li>资源抢夺问题，需要并发控制</li></ul><h2 id="2-线程实现（重点）"><a href="#2-线程实现（重点）" class="headerlink" title="2. 线程实现（重点）"></a>2. 线程实现（重点）</h2><h3 id="2-1-三种实现方式"><a href="#2-1-三种实现方式" class="headerlink" title="2.1 三种实现方式"></a>2.1 三种实现方式</h3><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623092650621.png" alt="三种实现方式"></p><h4 id="2-1-1继承Thread类"><a href="#2-1-1继承Thread类" class="headerlink" title="2.1.1继承Thread类"></a>2.1.1继承Thread类</h4><h6 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h6><ol><li>自定义线程类，继承Thread</li><li>重写 <code>run()</code> 方法</li><li>调用 <code>start()</code> 方法启动线程</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"run方法线程"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// start启动，run不是多线程</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        testThread1.start();</span><br><span class="line">        <span class="comment">// main线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"MMMMMMMMMMMMMM"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>PS: 线程开启不一定立即执行，由CPU调度执行</strong></p><h5 id="实例：图片下载"><a href="#实例：图片下载" class="headerlink" title="实例：图片下载"></a>实例：图片下载</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread2</span><span class="params">(String url, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        TestThread2 testThread1 = <span class="keyword">new</span> TestThread2(<span class="string">"https://commons.apache.org/proper/commons-io/images/commons-logo.png"</span>, <span class="string">"1.png"</span>);</span><br><span class="line">        TestThread2 testThread2 = <span class="keyword">new</span> TestThread2(<span class="string">"https://commons.apache.org/proper/commons-io/images/io-logo-white.png"</span>, <span class="string">"2.png"</span>);</span><br><span class="line">        TestThread2 testThread3 = <span class="keyword">new</span> TestThread2(<span class="string">"http://www.apache.org/events/current-event-125x125.png"</span>, <span class="string">"3.png"</span>);</span><br><span class="line"></span><br><span class="line">        testThread1.start();</span><br><span class="line">        testThread2.start();</span><br><span class="line">        testThread3.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// run方法负责调用下载方法</span></span><br><span class="line">        WebDownload webDownload = <span class="keyword">new</span> WebDownload();</span><br><span class="line">        webDownload.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件，名为"</span> + name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebDownload</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>{</span><br><span class="line">            String path = <span class="string">"F:/AWork/Project/2021/JavaDataStructure/src/com/songx64/baselearn/threadlearn/kuangThread/"</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(path+name));</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"IO异常，下载出错"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>需要Apache的一个包 <code>commons-io</code> ：<a href="https://commons.apache.org/proper/commons-io/">Commons IO – Commons IO Overview (apache.org)</a>，用于文件下载</p><p>下载后Add to Library。</p><h3 id="2-2-Runnable实现线程"><a href="#2-2-Runnable实现线程" class="headerlink" title="2.2 Runnable实现线程"></a>2.2 Runnable实现线程</h3><ol><li>创建类实现 <code>Runnable</code> 接口</li><li>创建 类的对象</li><li>将对象传入 <code>Thread()</code> 构造函数中</li><li>调用 Thread 实例的 start() </li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 下面这两行，需要将Runnable对象传入Thread类</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"RRRRRRRRRRRRRRRRRRRR"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Thread-与-Runnable-对比"><a href="#Thread-与-Runnable-对比" class="headerlink" title="Thread 与 Runnable 对比"></a>Thread 与 Runnable 对比</h4><ul><li>继承 Thread 类：<ul><li>启动线程：子类对象.start()</li><li>不推荐使用：避免单继承局限性</li></ul></li><li>实现 Runnable 接口：<ul><li>启动线程：new Thread(对象) + <code>thread.start()</code></li><li>推荐使用：没有单继承局限性，方便同一个对象被多个线程使用</li></ul></li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623102002126.png" alt="Runnable可以被重复使用"></p><p>Thread：基于继承；Runnable：基于组合；创建Thread比一个Runnable成本要昂贵一点。/</p><h3 id="实例：初识线程并发问题"><a href="#实例：初识线程并发问题" class="headerlink" title="实例：初识线程并发问题"></a>实例：初识线程并发问题</h3><p>卖票问题</p><ul><li><code>Thread.currentThread.getName()</code> ：得到当前正在执行的线程方法</li><li><code>Thread.sleep(200)</code> ：此线程暂停200ms</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread4</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        TestThread4 t = <span class="keyword">new</span> TestThread4();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(t, <span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t, <span class="string">"Bob"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t, <span class="string">"牛牛"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在并发问题，票会超卖</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"拿到了"</span> + ticketNums-- + <span class="string">"张票"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁的话可以解决并发问题</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            synchronized (this){</span></span><br><span class="line"><span class="comment">                System.out.println(Thread.currentThread().getName()+"拿到了"+ticketNums--+"张票");</span></span><br><span class="line"><span class="comment">            }*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里还没讲怎么解决，看之后的。</p><h3 id="实例：龟兔赛跑"><a href="#实例：龟兔赛跑" class="headerlink" title="实例：龟兔赛跑"></a>实例：龟兔赛跑</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623104229483.png" alt="龟兔赛跑问题"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Race</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="comment">// 兔子每隔10步，睡个觉</span></span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"兔子"</span>) &amp;&amp; i%<span class="number">10</span>==<span class="number">0</span> ){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 跑步</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"跑了--&gt;"</span>+i+<span class="string">"步"</span>);</span><br><span class="line">            <span class="keyword">if</span> (gameOver(i)){</span><br><span class="line">                System.out.println(<span class="string">"Winner is "</span> + winner);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Race race = <span class="keyword">new</span> Race();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">"兔子"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(race,<span class="string">"乌龟"</span>).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断，如果有人先跑到100步，那么游戏结束</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">gameOver</span><span class="params">(<span class="keyword">int</span> steps)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(steps &gt;= <span class="number">99</span>){</span><br><span class="line">                winner = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-Callable接口实现"><a href="#2-3-Callable接口实现" class="headerlink" title="2.3 Callable接口实现"></a>2.3 Callable接口实现</h3><p>Callable其实相当于一个增强的Runnable，带有返回结果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        TestCallable tc1 = <span class="keyword">new</span> TestCallable(<span class="string">"https://commons.apache.org/proper/commons-io/images/commons-logo.png"</span>, <span class="string">"1.png"</span>);</span><br><span class="line">        TestCallable tc2 = <span class="keyword">new</span> TestCallable(<span class="string">"https://commons.apache.org/proper/commons-io/images/io-logo-white.png"</span>, <span class="string">"2.png"</span>);</span><br><span class="line">        TestCallable tc3 = <span class="keyword">new</span> TestCallable(<span class="string">"http://www.apache.org/events/current-event-125x125.png"</span>, <span class="string">"3.png"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主要就是这块，提交到线程池，然后使用Future获取返回结果并get</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        Future&lt;Boolean&gt; result1 = service.submit(tc1);</span><br><span class="line">        Future&lt;Boolean&gt; result2 = service.submit(tc2);</span><br><span class="line">        Future&lt;Boolean&gt; result3 = service.submit(tc3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"result1 == "</span> +result1.get());</span><br><span class="line">        System.out.println(<span class="string">"result2 == "</span> +result2.get());</span><br><span class="line">        System.out.println(<span class="string">"result3 == "</span> +result3.get());</span><br><span class="line">        <span class="comment">// 最后需要关闭服务</span></span><br><span class="line">        service.shutdownNow();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// run方法负责调用下载方法</span></span><br><span class="line">        WebDownload webDownload = <span class="keyword">new</span> WebDownload();</span><br><span class="line">        webDownload.downloader(url, name);</span><br><span class="line">        System.out.println(<span class="string">"下载了文件，名为"</span> + name);</span><br><span class="line">        <span class="keyword">if</span>(name == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebDownload</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloader</span><span class="params">(String url, String name)</span> </span>{</span><br><span class="line">            String path = <span class="string">"F:/AWork/Project/2021/JavaDataStructure/src/com/songx64/baselearn/threadlearn/kuangThread/"</span>;</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                FileUtils.copyURLToFile(<span class="keyword">new</span> URL(url), <span class="keyword">new</span> File(path+name));</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">"IO异常，下载出错"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>继承Callable的时候会有个泛型，指定返回值的类型。</p><p>然后实现的是 <code>call()</code> 方法，带有返回值。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623114458832.png" alt="Callable步骤"></p><h3 id="2-4-静态代理模式"><a href="#2-4-静态代理模式" class="headerlink" title="2.4 静态代理模式"></a>2.4 静态代理模式</h3><p>多线程的 Thread 和 Runnable 就是静态代理模式。</p><blockquote><p><a href="https://www.runoob.com/design-pattern/proxy-pattern.html">代理模式 | 菜鸟教程 (runoob.com)</a></p><p>在代理模式（Proxy Pattern）中，<strong>一个类代表另一个类的功能</strong>。这种类型的设计模式属于结构型模式。</p><p><strong>主要解决：</strong>在直接访问对象时带来的问题</p><p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p><p><strong>如何解决：</strong>增加中间层。</p><p><strong>关键代码：</strong>实现与被代理类组合。</p></blockquote><p>这里举个例子：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623152348219.png" alt="image-20210623152348219"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理模式总结;</span></span><br><span class="line"><span class="comment">// 真实对象和代理对象都要实现同一个接口</span></span><br><span class="line"><span class="comment">// 代理对象要代理真实角色</span></span><br><span class="line"><span class="comment">// 好处:</span></span><br><span class="line">    <span class="comment">// 代理对象可以做很多真实对象做不了的事情</span></span><br><span class="line">    <span class="comment">// 真实对象专注做自已的事情</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        WeddingCompany weddingCompany = <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You());</span><br><span class="line">        weddingCompany.HappyMarry();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对比这个静态代理模式，和多线程的格式，可以看到多线程其实也是一样的</span></span><br><span class="line">        <span class="comment">// Thread 继承了 Runnable接口</span></span><br><span class="line">        <span class="keyword">new</span> WeddingCompany(<span class="keyword">new</span> You()).HappyMarry();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestRunnable()).start();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//结婚接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Marry</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//你来结婚</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">You</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"结婚，Happy"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 婚庆公司，代理你做一些事情</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeddingCompany</span> <span class="keyword">implements</span> <span class="title">Marry</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Marry target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeddingCompany</span><span class="params">(Marry target)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HappyMarry</span><span class="params">()</span> </span>{</span><br><span class="line">        before();</span><br><span class="line">        <span class="comment">// 调用真实对象的方法</span></span><br><span class="line">        <span class="keyword">this</span>.target.HappyMarry();</span><br><span class="line">        after();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"结婚之前，布置现场"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"结婚之后，收拾残局"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-线程状态"><a href="#3-线程状态" class="headerlink" title="3. 线程状态"></a>3. 线程状态</h2><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623165623780.png" alt="线程的五大状态"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210623165724644.png" alt="Java中的线程状态变化"></p><h3 id="3-1-停止线程-建议标志位"><a href="#3-1-停止线程-建议标志位" class="headerlink" title="3.1 停止线程 建议标志位"></a>3.1 停止线程 建议标志位</h3><ul><li>不推荐使用JDK提供的stop()、destroy()等方法。【已废弃】</li><li>推荐线程自己停止下来</li><li>建议使用一个标志位进行终止变量当flag=false，则终止线程运行。</li></ul><p>标志位的方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试stop</span></span><br><span class="line"><span class="comment">// 1.建议线程正常停止---&gt;利用次数,不建议死循环。</span></span><br><span class="line"><span class="comment">// 2.建议使用标志位---&gt;设置一个标志位</span></span><br><span class="line"><span class="comment">// 3.不要使用stop或者destroy等过时或者JDK不建议使用的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="comment">// 1.设置标志位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2. 根据标志位判断，是否执行</span></span><br><span class="line">        <span class="keyword">while</span> (flag){</span><br><span class="line">            System.out.println(<span class="string">"Thread is Running --"</span> + i++);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 公共方法，修改标志位，停止线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myStop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        TestStop t = <span class="keyword">new</span> TestStop();</span><br><span class="line">        <span class="keyword">new</span> Thread(t).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 次数太少的话，子线程可能抢不到时间片</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE/<span class="number">2</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"main--"</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(i == Integer.MAX_VALUE/<span class="number">400000</span>){</span><br><span class="line">                t.myStop();</span><br><span class="line">                System.out.println(<span class="string">"Stop At "</span> +i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-线程休眠-sleep-int-ms"><a href="#3-2-线程休眠-sleep-int-ms" class="headerlink" title="3.2 线程休眠 sleep(int ms)"></a>3.2 线程休眠 sleep(int ms)</h3><p><code>sleep()</code></p><ul><li><code>sleep(1000)</code> ，休眠1000毫秒，也就是1s</li><li>会抛出 <code>InterruptedException</code></li><li>调用 sleep，线程进入阻塞状态；sleep 时间到达后，进入就绪状态</li><li>sleep 不会释放对象的锁，wait 会释放对象锁</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span></span>{</span><br><span class="line">    <span class="comment">// 模拟倒计时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeCount</span><span class="params">(<span class="keyword">int</span> second)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        <span class="keyword">while</span> (second &gt; <span class="number">0</span>){</span><br><span class="line">            System.out.println(second--);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印系统当前时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timePrinter</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            System.out.println(dateFormat.format(<span class="keyword">new</span> Date(System.currentTimeMillis())));</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line"></span><br><span class="line">        TestSleep testSleep = <span class="keyword">new</span> TestSleep();</span><br><span class="line">        testSleep.timeCount(<span class="number">10</span>);</span><br><span class="line">        testSleep.timePrinter();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3-线程礼让-yield"><a href="#3-3-线程礼让-yield" class="headerlink" title="3.3 线程礼让 yield()"></a>3.3 线程礼让 yield()</h3><ul><li>礼让线程，让当前正在执行的线程暂停，但不阻塞将线程</li><li>从运行状态转为就绪状态</li><li>让cpu重新调度，礼让不一定成功!看CPU心情</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestYield</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable runnable = ()-&gt;{</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程开始执行"</span>);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 线程停止"</span>);</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"线程A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable,<span class="string">"线程B"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PS:我礼让就没成功过。。电脑的原因吗</p><h3 id="3-4-线程强制执行-join"><a href="#3-4-线程强制执行-join" class="headerlink" title="3.4 线程强制执行 join()"></a>3.4 线程强制执行 join()</h3><ul><li><code>join()</code> 合并线程，待此线程执行完之后，再执行其他线程，其他线程阻塞</li><li>可以想象成插队</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Join线程-------------"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        TestJoin testJoin = <span class="keyword">new</span> TestJoin();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) {</span><br><span class="line">            <span class="comment">// 当主线程 200 的时候，让thread插队</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1000</span>){</span><br><span class="line">                thread.join();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"Main线程 + "</span> + i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-5-线程状态观测-getState"><a href="#3-5-线程状态观测-getState" class="headerlink" title="3.5 线程状态观测 getState()"></a>3.5 线程状态观测 getState()</h3><blockquote><p>JDK1.8文档：</p><p>public static enum Thread.State<br>extends Enum&lt;Thread.State&gt;<br>线程状态。线程可以处于以下状态之一：</p><ul><li><p>NEW<br><strong>尚未启动</strong>的线程处于此状态。</p></li><li><p>RUNNABLE<br>在Java虚拟机中<strong>执行</strong>的线程处于此状态。</p></li><li><p>BLOCKED<br>被<strong>阻塞</strong>等待监视器锁定的线程处于此状态。</p></li><li><p>WAITING<br>正在<strong>等待另一个线程</strong>执行特定动作的线程处于此状态。</p></li><li><p>TIMED_WAITING<br>正在<strong>等待另一个线程执行动作达到指定等待时间</strong>的线程处于此状态。</p></li><li><p>TERMINATED<br><strong>已退出</strong>的线程处于此状态。</p><p>一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。</p></li></ul></blockquote><p><strong><code>thread1.getState()</code> ：得到 thread1 的状态，上面的那几个值</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestState</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"///////"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        Thread.State state = thread.getState();</span><br><span class="line">        System.out.println(<span class="string">"start之前： "</span> + state);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(<span class="string">"start之后："</span> + state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (state != Thread.State.TERMINATED){</span><br><span class="line">            <span class="comment">// 这里一定要更新</span></span><br><span class="line">            state = thread.getState();</span><br><span class="line">            System.out.println(state);</span><br><span class="line">            Thread.yield();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(<span class="string">"线程死了！--"</span> + state);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 线程是一次性用品，死亡后不能再次启动</span></span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-6-线程优先级-getPriority"><a href="#3-6-线程优先级-getPriority" class="headerlink" title="3.6 线程优先级 getPriority()"></a>3.6 线程优先级 getPriority()</h3><ul><li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</li><li>线程的优先级用数字表示，范围从1~10.<br><code>Thread.MIN_PRIORITY = 1;</code><br><code>Thread.MAX_PRIORITY = 10;</code><br><code>Thread.NORM_PRIORITY = 5;</code></li><li>使用以下方式改变或获取优先级<ul><li><strong><code>getPriority() </code> :获取优先级</strong></li><li><strong><code>setPriority(int xxx)</code> ： 设置优先级</strong></li></ul></li></ul><p>线程执不执行还是得看CPU，优先级高的不一定先执行。但是优先级高的权重大，更可能先执行。</p><ul><li>性能倒置：优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPriority</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> + Thread.currentThread().getPriority() );</span><br><span class="line">        MyPriority myPriority = <span class="keyword">new</span> MyPriority();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(myPriority,<span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(myPriority,<span class="string">"t2"</span>);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(myPriority,<span class="string">"t3"</span>);</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> Thread(myPriority,<span class="string">"t4"</span>);</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> Thread(myPriority,<span class="string">"t5"</span>);</span><br><span class="line"></span><br><span class="line">        t1.setPriority(<span class="number">1</span>);</span><br><span class="line">        t2.setPriority(<span class="number">2</span>);</span><br><span class="line">        t3.setPriority(<span class="number">3</span>);</span><br><span class="line">        t4.setPriority(<span class="number">4</span>);</span><br><span class="line">        t5.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        t4.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPriority</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" --&gt; "</span> + Thread.currentThread().getPriority() );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-7-守护线程-setDaemon-boolean"><a href="#3-7-守护线程-setDaemon-boolean" class="headerlink" title="3.7 守护线程 setDaemon(boolean)"></a>3.7 守护线程 setDaemon(boolean)</h3><ul><li>线程分为用户线程和守护线程</li><li>虚拟机必须确保用户线程执行完毕：如 <code>main</code> 线程</li><li>虚拟机不用等待守护线程执行完毕：如后台记录操作日志、监控内存、垃圾回收GC线程等..</li></ul><p><strong><code>thread1.setDaemon(true)</code> ：将线程 thread1  设为守护线程</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaemon</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Bless bless = <span class="keyword">new</span> Bless();</span><br><span class="line">        NormalT normalT = <span class="keyword">new</span> NormalT();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(bless);</span><br><span class="line">        <span class="comment">// 默认false表示为正常线程，true表示设为守护线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(normalT);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以看到，主线程和Normal线程结束之后，程序结束。守护线程死循环也终止了</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bless</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            System.out.println(<span class="string">"God Bless You"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalT</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {</span><br><span class="line">            System.out.println(<span class="string">"此线程存活"</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"此线程死亡"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-线程同步（重点）"><a href="#4-线程同步（重点）" class="headerlink" title="4. 线程同步（重点）"></a>4. 线程同步（重点）</h2><p>并发：同一个对象被多个线程<strong>同时操作</strong></p><p>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。</p><p>线程同步其实就是一种<strong>等待机制</strong>，多个需要同时访问此对象的线程进入<strong>这个对象的等待池形成队列</strong>，等待前面线程使用完毕，下一个线程再使用。</p><ul><li>队列 + 锁，解决线程同步的安全性。</li></ul><p><strong>synchronized，排他锁独占资源。</strong></p><ul><li>使用锁可能会引起问题：<ul><li>一个线程持有锁会导致其他所有需要此锁的<strong>线程挂起</strong>;</li><li>在多线程竞争下,加锁﹐释放锁会导致比较多的上下文切换和调度延时,引起<strong>性能问题</strong>;</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致<strong>优先级倒置</strong>﹐引起性能问题．</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>产生死锁的四个必要条件:<br>1．互斥条件:一个资源每次只能被一个进程使用。<br>2．请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。3．不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生</p><p>写个死锁案例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i1, i2, <span class="number">0</span>), <span class="string">"线程1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i1, i2, <span class="number">1</span>), <span class="string">"线程2"</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer i1;</span><br><span class="line">    <span class="keyword">private</span> Integer i2;</span><br><span class="line">    <span class="keyword">private</span> Integer choice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Integer i1, Integer i2, Integer choice)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.i1 = i1;</span><br><span class="line">        <span class="keyword">this</span>.i2 = i2;</span><br><span class="line">        <span class="keyword">this</span>.choice = choice;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 用一个choice，分别先拿不同资源</span></span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 先拿1，再拿2</span></span><br><span class="line">            <span class="keyword">synchronized</span> (i1) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i1: "</span> + i1);</span><br><span class="line">                <span class="comment">// 将两个这个拿到外层，可以解决死锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (i2) {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i2: "</span> + i2);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 先拿2，再拿1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (i2) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i2: "</span> + i2);</span><br><span class="line">                <span class="keyword">synchronized</span> (i1) {</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i1: "</span> + i1);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将最后一段的代码改为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 用一个choice，分别先拿不同资源</span></span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 先拿1，再拿2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (i1) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i1: "</span> + i1);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">synchronized</span> (i2) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i2: "</span> + i2);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 先拿2，再拿1</span></span><br><span class="line">        <span class="keyword">synchronized</span> (i2) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i2: "</span> + i2);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">synchronized</span> (i1) {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"得到了i1: "</span> + i1);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样就能避免死锁了。为啥呢？我自己理解的，是锁升级到重量级锁了，阻塞了其中的一个线程。</p><h3 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h3><p>JUC，就是 <code>import java.util.concurrent</code> 类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2,<span class="string">"小明"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2,<span class="string">"小二"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2,<span class="string">"小王"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tirckNums = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>){</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (tirckNums &gt; <span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+tirckNums--);</span><br><span class="line">                }<span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>手动锁，自己调用 <code>lock</code> 和 <code>unlock</code> ，锁代码块。</p><ul><li>Lock是<strong>显式锁</strong>（手动开启和关闭锁，别忘记关闭锁) ；synchronized是<strong>隐式锁</strong>，出了作用域自动释放</li><li>Lock只有<strong>代码块锁</strong>，synchronized有<strong>代码块锁和方法锁</strong></li><li>使用Lock锁，JVM将花费较少的时间来调度线程，<strong>性能</strong>更好。并且具有更好的扩展性(提供更多的子类)</li><li>优先使用顺序：Lock &gt;同步代码块(已经进入了方法体，分配了相应资源)&gt;同步方法（在方法体之外)</li></ul><h2 id="5-线程通信问题"><a href="#5-线程通信问题" class="headerlink" title="5. 线程通信问题"></a>5. 线程通信问题</h2><h3 id="5-1-生产者消费者问题"><a href="#5-1-生产者消费者问题" class="headerlink" title="5.1  生产者消费者问题"></a>5.1  生产者消费者问题</h3><blockquote><p>可以观看：<a href="https://www.jianshu.com/p/e29632593057">一篇文章，让你彻底弄懂生产者–消费者问题 - 简书 (jianshu.com)</a> ，使用了3种不同的方法。</p></blockquote><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210625203857582.png" alt="生产者消费者问题"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210625204026475.png" alt="问题分析"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210625204128447.png" alt="Java方法"></p><ol><li><p>并发协作模型“生产者Ⅰ消费者模式”—&gt;管程法    </p><ul><li>生产者:负责生产数据的模块(可能是方法﹐对象﹐线程﹐进程);</li><li>消费者:负责处理数据的模块(可能是方法﹐对象﹐线程,进程);</li><li>缓冲区∶消费者不能直接使用生产者的数据﹐他们之间有个“缓冲区</li></ul><p> 生产者将生产好的数据<strong>放入缓冲区 <strong>，消费者从缓冲区</strong>拿出数据</strong></p></li><li><p>并发协作模型“生产者/消费者模式”—&gt;信号灯法</p><p> 就是一个标志位</p></li></ol><h3 id="5-2-管程法"><a href="#5-2-管程法" class="headerlink" title="5.2 管程法"></a>5.2 管程法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SynContainer synContainer = <span class="keyword">new</span> SynContainer();</span><br><span class="line"></span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(synContainer);</span><br><span class="line">        Consumer consumer =<span class="keyword">new</span> Consumer(synContainer);</span><br><span class="line"></span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line"></span><br><span class="line">    SynContainer synContainer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SynContainer synContainer)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.synContainer = synContainer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 生产</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            synContainer.push(<span class="keyword">new</span> Production(i));</span><br><span class="line">            System.out.println(<span class="string">"生产者生产了--&gt; "</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    SynContainer synContainer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SynContainer synContainer)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.synContainer = synContainer;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> id = synContainer.pop().id;</span><br><span class="line">            System.out.println(<span class="string">"消费者消费了--&gt; "</span> + id);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Production</span> </span>{</span><br><span class="line">    <span class="comment">// 产品编号</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Production</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer</span> </span>{</span><br><span class="line">    <span class="comment">// 缓冲区容器，总容量</span></span><br><span class="line">    Production[] productions = <span class="keyword">new</span> Production[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 当前存在的容量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Production production)</span> </span>{</span><br><span class="line">        <span class="comment">// 缓冲区已满</span></span><br><span class="line">        <span class="keyword">if</span> (count == productions.length) {</span><br><span class="line">            <span class="comment">// 缓冲区已满，生产者停止生产；</span></span><br><span class="line">            <span class="comment">// 通知消费者，进行消费</span></span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 放入</span></span><br><span class="line">        productions[count] = production;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 生产出来了，通知消费者，可以立即消费</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者取走产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Production <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>){</span><br><span class="line">            <span class="comment">// 通知生产者生产</span></span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            }<span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出</span></span><br><span class="line">        count--;</span><br><span class="line">        Production production = productions[count];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出之后，缓冲区有空格了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> production;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><a href="https://www.cnblogs.com/xidongyu/p/10891303.html">Java中的管程 - 被罚站的树 - 博客园 (cnblogs.com)</a></p><p>Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。但是<strong>管程利用OOP的封装特性解决了信号量在工程实践上的复杂性问题</strong>，因此java采用管理机制。</p><p>所谓<strong>管程，指的是管理共享变量以及对其操作过程，让它们支持并发访问</strong>。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p><p>有一点需要再次提醒，对于 MESA 管程来说，有一个编程范式，就是==需要在一个 while 循环里面调用 wait()==。<strong>这个是 MESA 管程特有的</strong>。</p></blockquote><h3 id="5-3-信号灯法"><a href="#5-3-信号灯法" class="headerlink" title="5.3 信号灯法"></a>5.3 信号灯法</h3><blockquote><p><a href="https://www.cnblogs.com/freebird92/p/6236415.html">JAVA并发框架之Semaphore实现生产者与消费者模型 - 陈峰 - 博客园 (cnblogs.com)</a></p></blockquote><p>锁和 <strong>信号量（Semaphore）</strong> 是实现多线程同步的两种常用的手段。</p><p>信号量需要初始化一个许可值，许可值可以大于0，也可以小于0，也可以等于0.</p><ul><li>如果大于0，表示，还有许可证可以发放，线程不会被阻塞；</li><li>如果小于或者等于0，表示，没有许可证可以发放了，线程被阻塞住了。   </li></ul><p>它有两个常用的操作：</p><ul><li><code>acquire()</code> 申请许可证，如果有，就可以获得，如果没有就等待了。相当于减法。</li><li><code>release()</code> 归还许可证，保证循环使用。相当于加法。</li></ul><p> 看一个例子，就会明白了，还是实现上次的那个生产者和消费者的例子。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.songx64.baselearn.threadlearn.kuangThread.gaoji;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created on 2021/6/26,上午 11:03</span></span><br><span class="line"><span class="comment"> * 信号量机制 Semaphore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SongX64</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPC2</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SynContainer2 synContainer2 = <span class="keyword">new</span> SynContainer2();</span><br><span class="line">        Thread p1 = <span class="keyword">new</span> Producer2(synContainer2);</span><br><span class="line">        Thread c1 = <span class="keyword">new</span> Consumer2(synContainer2);</span><br><span class="line">        Thread c2 = <span class="keyword">new</span> Consumer2(synContainer2);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Production2</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Production2</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    SynContainer2 synContainer2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer2</span><span class="params">(SynContainer2 synContainer2)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.synContainer2 = synContainer2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            synContainer2.push(<span class="keyword">new</span> Production2(i));</span><br><span class="line">            System.out.println(<span class="string">"生产了--&gt;"</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">    SynContainer2 synContainer2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer2</span><span class="params">(SynContainer2 synContainer2)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.synContainer2 = synContainer2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> id = synContainer2.pop().id;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"消费了&lt;--"</span> + id);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓冲区</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynContainer2</span> </span>{</span><br><span class="line">    <span class="comment">// 容器</span></span><br><span class="line">    LinkedList&lt;Production2&gt; production2s = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 互斥信号量，保证安全性</span></span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 为满信号量，初始是最大容量</span></span><br><span class="line">    Semaphore isFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 为空信号量</span></span><br><span class="line">    Semaphore isEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者生产，为满阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Production2 production2)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//大于0，就放行</span></span><br><span class="line">            <span class="comment">//acquire，就是减操作，如果 &lt;=0，就阻塞</span></span><br><span class="line">            <span class="comment">//release，就是加操作，如果 &gt;0，就不会被阻塞</span></span><br><span class="line">            isFull.acquire();</span><br><span class="line">            <span class="comment">// 添加操作是互斥的，因为占用了缓冲区</span></span><br><span class="line">            mutex.acquire();</span><br><span class="line">            <span class="keyword">int</span> i = isFull.availablePermits();</span><br><span class="line">            production2s.add(production2);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 释放互斥锁</span></span><br><span class="line">            mutex.release();</span><br><span class="line">            <span class="comment">// 生产完成后，让空的增加，可以进行消费</span></span><br><span class="line">            isEmpty.release();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费者消费，为空阻塞</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Production2 <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        Production2 temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为空减少一个信号量，如果是空的0再减就阻塞了；</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            isEmpty.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            temp = production2s.removeLast();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            mutex.release();</span><br><span class="line">            isFull.release();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写的有点乱。。。但是知道Semaphore的用法就行了</p><h2 id="6-高级主题"><a href="#6-高级主题" class="headerlink" title="6.高级主题"></a>6.高级主题</h2><h3 id="6-1线程池"><a href="#6-1线程池" class="headerlink" title="6.1线程池"></a>6.1线程池</h3><ul><li>背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对<strong>性能</strong>影响很大。</li><li>思路:提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li><li>好处:<ul><li>提高响应速度(减少了创建新线程的时间)</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建)</li><li>便于线程管理(….)<ul><li>corePoolSize:核心池的大小</li><li>maximumPoolSize:最大线程数</li><li>keepAliveTime:线程没有任务时最多保持多长时间后会终止</li></ul></li></ul></li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210626121844174.png" alt="Java线程池类"></p><p>简单使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 手动创建线程池（建议），指定参数</span></span><br><span class="line">        <span class="comment">// 参数：核心线程数，最大线程数，核心线程外的工作线程存活时间，时间单位，阻塞队列</span></span><br><span class="line">        ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                <span class="number">20</span>,</span><br><span class="line">                <span class="number">100</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 自动创建线程池（不建议），10个核心线程/最大线程</span></span><br><span class="line">        <span class="comment">//ExecutorService executorService = Executors.newFixedThreadPool(10);</span></span><br><span class="line"></span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程学习&quot;&gt;&lt;a href=&quot;#多线程学习&quot; class=&quot;headerlink&quot; title=&quot;多线程学习&quot;&gt;&lt;/a&gt;多线程学习&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1V4</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="多线程" scheme="https://songx64.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java单例模式</title>
    <link href="https://songx64.github.io/2021/06/24/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://songx64.github.io/2021/06/24/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-24T08:49:37.000Z</published>
    <updated>2021-06-26T10:41:23.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java单例模式"><a href="#Java单例模式" class="headerlink" title="Java单例模式"></a>Java单例模式</h1><blockquote><p><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></p></blockquote><h2 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2><ul><li>创建型模式</li><li>一个类有且只有一个对象</li></ul><p>要点：</p><ul><li>构造函数私有化</li><li>类返回静态的一个对象</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/62576915-36E0-4B67-B078-704699CA980A.jpg" alt="单例模式的 UML 图"></p><h2 id="Java几种实现方式"><a href="#Java几种实现方式" class="headerlink" title="Java几种实现方式"></a>Java几种实现方式</h2><p>首先提一下<strong>懒汉模式</strong>与<strong>饿汉模式</strong>：</p><ul><li>懒汉：需要的时候才创建</li><li>饿汉：上来就直接创建</li></ul><p>然后就是多线程是否安全。<br>这里的线程安全是指，多线程可能创建多个单例对象。</p><h3 id="1-最简单的懒汉模式"><a href="#1-最简单的懒汉模式" class="headerlink" title="1.最简单的懒汉模式"></a>1.最简单的懒汉模式</h3><ul><li>懒汉</li><li>线程不安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">// 静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个返回实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instace == <span class="keyword">null</span>){</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-懒汉模式方法加锁"><a href="#2-懒汉模式方法加锁" class="headerlink" title="2.懒汉模式方法加锁"></a>2.懒汉模式方法加锁</h3><ul><li>懒汉</li><li>线程安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstace</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>直接给get方法加了锁，可能性能较低。</p><h3 id="3-双重验证"><a href="#3-双重验证" class="headerlink" title="3. 双重验证"></a>3. 双重验证</h3><p>DCL：double-check locking</p><ul><li>懒汉</li><li>线程安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">// volatile禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 双重验证</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">// 对类加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class){</span><br><span class="line">                <span class="comment">// 第二层验证，防止通过第一个判断的，阻塞中的第二个线程，得到锁后再次new</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-饿汉式"><a href="#4-饿汉式" class="headerlink" title="4. 饿汉式"></a>4. 饿汉式</h3><ul><li>饿汉</li><li>线程安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">// 饿汉直接创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{}</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上来就创建，浪费内存；容易产生垃圾对象。使用了 <strong>classloader 机制</strong>来保证了线程安全。</p><h3 id="5-静态内部类"><a href="#5-静态内部类" class="headerlink" title="5.静态内部类"></a>5.静态内部类</h3><ul><li>懒汉</li><li>线程安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{}</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个static内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>{</span><br><span class="line">        <span class="comment">// final关键字，并新建</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singlton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get函数直接返回内部类成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> <strong>SingletonHolder 类没有被主动使用</strong>，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化  instance。</p><h3 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h3><p>jdk1.5之后添加了enmu；</p><ul><li>饿汉</li><li>线程安全</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> enmu Singleton{</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Do Something！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不会被反射机制破解。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一般直接使用饿汉式；</p><p>如要使用 <strong>懒汉式</strong> 则一般建议使用 <strong>静态内部类</strong> 的方法；</p><p>有特殊要求则使用 <strong>双重验证</strong> 方式；</p><p>如涉及 <strong>反序列化</strong> 则使用 <strong>枚举</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java单例模式&quot;&gt;&lt;a href=&quot;#Java单例模式&quot; class=&quot;headerlink&quot; title=&quot;Java单例模式&quot;&gt;&lt;/a&gt;Java单例模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/d</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中的锁</title>
    <link href="https://songx64.github.io/2021/06/17/Java%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://songx64.github.io/2021/06/17/Java%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-06-17T14:03:05.000Z</published>
    <updated>2021-06-26T10:24:57.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://zhuanlan.zhihu.com/p/71156910">通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！ - 知乎 (zhihu.com)</a></p></blockquote><p>锁分类</p><ul><li>悲观锁，乐观锁</li><li>可重入锁</li><li>可中断锁</li><li>公平锁，非公平锁</li><li>读锁(共享锁)，写锁(排他锁/互斥锁)</li><li>自旋锁</li></ul><h2 id="一、悲观锁与乐观锁"><a href="#一、悲观锁与乐观锁" class="headerlink" title="一、悲观锁与乐观锁"></a>一、悲观锁与乐观锁</h2><ul><li><p>悲观锁：认为数据随时都可能更改，操作之前先加锁，别的人都不能获取此数据。</p></li><li><p>乐观锁：认为数据一般不会被更改，操作的时候会检查数据是否更新，发现数据变了，重新读取重新进行操作。</p></li></ul><p><strong>悲观锁阻塞事务，乐观锁回滚重试</strong></p><h2 id="二、乐观锁基础——CAS"><a href="#二、乐观锁基础——CAS" class="headerlink" title="二、乐观锁基础——CAS"></a>二、乐观锁基础——CAS</h2><p>CAS，就是比较并替换，Compare And Swap 。</p><p>每一个CAS操作过程都包含3个运算参数：一个内存地址V（当前值），一个期望的值A（旧值）和一个新值B。</p><p>CAS的基本思路就是，如果内存地址V上的值和期望的值A相等，则给其赋予新值B，否则不做任何事儿。</p><p>CAS就是在一个循环里不断的做CAS操作，直到成功为止。</p><p>比如一个基于CAS实现更新的例子（伪代码）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>{</span><br><span class="line">    oldValue = V.get(); <span class="comment">//读取共享变量V的旧值</span></span><br><span class="line">    newValue = calculate(oldValue); <span class="comment">// 计算变量V的新值</span></span><br><span class="line">} <span class="keyword">while</span>(!compareAndSwap(V, oldValue, <span class="keyword">new</span> Value));</span><br><span class="line"><span class="comment">// 在while条件中调用更新，更新成功则true失败则重试</span></span><br></pre></td></tr></tbody></table></figure><p>CAS是一个CPU原子指令。</p><p>因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为无锁编程。换句话说，<strong>乐观锁其实不是“锁”，它仅仅是一个循环重试CAS的算法而已！</strong></p><h2 id="三、自旋锁"><a href="#三、自旋锁" class="headerlink" title="三、自旋锁"></a>三、自旋锁</h2><p>有一种锁叫自旋锁。所谓自旋，说白了就是一个 while(true) 无限循环。</p><p>刚刚的乐观锁就有类似的无限循环操作，那么它是自旋锁吗？</p><p>不是。尽管<strong>自旋与 while(true) 的操作是一样的，但还是应该将这两个术语分开</strong>。“自旋”这两个字，特指自旋锁的自旋。</p><h2 id="四、synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁"><a href="#四、synchronized锁升级：偏向锁-→-轻量级锁-→-重量级锁" class="headerlink" title="四、synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁"></a>四、synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁</h2><h3 id="锁升级总结"><a href="#锁升级总结" class="headerlink" title="锁升级总结"></a>锁升级总结</h3><p>自己整理了一个流程图：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210617220417629.png" alt="synchronized锁升级/锁膨胀"></p><p>synchronized锁只会升级，不会降级。</p><ul><li>无锁（即CAS操作）</li><li>偏向锁（偏向于一个进程，发生竞争则升级）</li><li>轻量级锁（自旋锁，自旋次数达到阈值默认10则升级）</li><li>重量级锁</li></ul><p>前面提到，synchronized关键字就像是汽车的自动档，现在详细讲这个过程。一脚油门踩下去，synchronized会从无锁升级为偏向锁，再升级为轻量级锁，最后升级为重量级锁，就像自动换挡一样。</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。也就是CAS（CAS是基于无锁机制实现的）。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果发生竞争，其他竞争线程会阻塞挂起，而不是忙等，直到被唤醒。</p><h3 id="其他关于synchronized"><a href="#其他关于synchronized" class="headerlink" title="其他关于synchronized"></a>其他关于synchronized</h3><blockquote><p><a href="https://my.oschina.net/javaFamily/blog/4282524">死磕synchronized底层实现 - 敖丙 - OSCHINA - 中文开源技术交流社区</a></p></blockquote><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/007S8ZIlgy1gevjajeicqj30vv0q1784.jpg" alt="我git上的脑图我每次写完我都会重新更新，大家可以没事去看看。"></p><h2 id="五、可重入锁（递归锁）"><a href="#五、可重入锁（递归锁）" class="headerlink" title="五、可重入锁（递归锁）"></a>五、可重入锁（递归锁）</h2><p>当前线程持有锁，当前线程再次获取锁，可以得到，那就是可重入锁。</p><p>Java里只要以Reentrant开头命名的锁都是可重入锁，而且JDK提供的所有现成的Lock实现类，包括synchronized关键字锁都是可重入的。</p><p>StampedLock是不可重入锁。</p><h2 id="六、公平锁、非公平锁"><a href="#六、公平锁、非公平锁" class="headerlink" title="六、公平锁、非公平锁"></a>六、公平锁、非公平锁</h2><p>如果多个线程申请一把公平锁，那么当锁释放的时候，<strong>先申请的先得到</strong>，非常公平。</p><p>显然如果是非公平锁，<strong>后申请的线程可能先获取到锁</strong>，是随机或者按照其他优先级排序的。</p><p>ReentrantLock可以传入参数指定是否公平锁。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/v2-7a4a72fe7ace46095cd3ca2e6c5212d9_r.jpg" alt="公平锁参数"></p><p>synchronized是非公平锁。</p><h2 id="七、可中断锁"><a href="#七、可中断锁" class="headerlink" title="七、可中断锁"></a>七、可中断锁</h2><p>这里的关键是理解什么是中断。<strong>Java并没有提供任何直接中断某线程的方法，只提供了中断机制</strong>。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，<strong>Java的中断不能直接终止线程，而是需要被中断的线程自己决定怎么处理</strong>。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。</p><p>回到锁的话题上来，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是可中断锁。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lock接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">// 拿不到锁就一直等，拿到马上返回。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; <span class="comment">// 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>; <span class="comment">// 同上，可以自定义等待的时间。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="八、读写锁、共享锁、互斥锁"><a href="#八、读写锁、共享锁、互斥锁" class="headerlink" title="八、读写锁、共享锁、互斥锁"></a>八、读写锁、共享锁、互斥锁</h2><ul><li>读锁，共享锁。</li><li>写锁，排他锁，互斥锁。</li></ul><p>读锁，写锁，都是悲观锁。</p><p>JDK提供的唯一一个 <code>ReadWriteLock</code> 接口实现类是 <code>ReentrantReadWriteLock</code> 。看名字就知道，它不仅提供了读写锁，而是都是可重入锁。 除了两个接口方法以外，<code>ReentrantReadWriteLock</code>还提供了一些便于外界监控其内部工作状态的方法，这里就不一一展开。</p><h2 id="九、Java悲观锁乐观锁"><a href="#九、Java悲观锁乐观锁" class="headerlink" title="九、Java悲观锁乐观锁"></a>九、Java悲观锁乐观锁</h2><p><strong>我们在Java里使用的各种锁，几乎全都是悲观锁</strong>。</p><p>synchronized从偏向锁、轻量级锁到重量级锁，全是悲观锁。</p><p>JDK提供的Lock实现类全是悲观锁。</p><p>其实只要有“锁对象”出现，那么就一定是悲观锁。因为乐观锁不是锁，而是一个在循环里尝试CAS的算法。</p><p>那JDK并发包里到底有没有乐观锁呢？</p><p>有。<code>java.util.concurrent.atomic</code>包里面的原子类都是利用乐观锁实现的。</p><p>问题：CAS与自旋的区别？也就是无锁和轻量级锁/自旋锁的区别？</p><p>答：貌似懂了，举个例子，修改变量值：CAS是不断读取变量值，并尝试操作；而自旋锁是不断检查修改值的这段代码锁是否可获取，并不去读具体的值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71156910&quot;&gt;通俗易懂 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁、各种锁及其Java实现！ - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="多线程" scheme="https://songx64.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>联合索引与最左原则</title>
    <link href="https://songx64.github.io/2021/06/16/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/"/>
    <id>https://songx64.github.io/2021/06/16/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%9C%80%E5%B7%A6%E5%8E%9F%E5%88%99/</id>
    <published>2021-06-16T09:07:19.000Z</published>
    <updated>2021-06-16T09:17:54.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合索引了解不，最左侧匹配原则是啥？"><a href="#联合索引了解不，最左侧匹配原则是啥？" class="headerlink" title="联合索引了解不，最左侧匹配原则是啥？"></a>联合索引了解不，最左侧匹配原则是啥？</h1><hr><blockquote><ol><li><a href="https://www.cnblogs.com/softidea/p/5977860.html">mysql联合索引 - 沧海一滴 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/-mrl/p/13230006.html">MYSQL | 最左匹配原则 - 一个人的孤独自白 - 博客园 (cnblogs.com)</a></li></ol></blockquote><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引又叫复合索引。两个或更多个列上的索引被称作复合索引。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX (`col1`,`col2`,`col3`);</span><br></pre></td></tr></tbody></table></figure><p>1、需要加索引的字段，要在where条件中<br>2、数据量少的字段不需要加索引<br>3、如果where条件中是<strong>OR</strong>关系，加索引不起作用<br>4、符合最<strong>左</strong>原则</p><h2 id="最左原则"><a href="#最左原则" class="headerlink" title="最左原则"></a>最左原则</h2><p>当创建 <code>(col1,col2,col3)</code> 联合索引时，<br>相当于创建了 <code>(col)</code> 单列索引， <code>(clo1,clo2)</code> 联合索引以及 <code>(col1,col2,col3)</code> </p><p>联合索引想要索引生效，只能使用 <code>col1</code> 和 <code>col1,col2</code> 和col1,col2,col3三种组合；</p><p>当然，<code>col1,col3</code> 组合也可以，但实际上只用到了<code>col1</code> 的索引，<code>col3</code> 并没有用到！</p><h2 id="注意事项与示例"><a href="#注意事项与示例" class="headerlink" title="注意事项与示例"></a>注意事项与示例</h2><ul><li><p>查询语句中的where、order by、group 涉及多个字段，一般需要创建多列索引</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> nick_name <span class="operator">=</span> <span class="string">'ligoudan'</span> <span class="keyword">and</span> job <span class="operator">=</span> <span class="string">'dog'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>一般情况下，把选择性高使用频率高的字段放在前面</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="string">'20'</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">'zh'</span> <span class="keyword">order</span> <span class="keyword">by</span> nick_name;</span><br><span class="line"># 这时候如果建索引的话，首字段应该是age，因为age定位到的数据更少，选择性更高。</span><br><span class="line"># 但是务必注意一点，满足了某个查询场景就可能导致另外一个查询场景更慢。</span><br></pre></td></tr></tbody></table></figure></li><li><p>避免使用范围查询</p></li><li><p>尽量避免查询不需要的数据，也就是尽量写明 <code> select 列名</code> 而不是 <code>select *</code></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span>将会全表遍历</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> job <span class="keyword">like</span> <span class="string">'%ligoudan%'</span>;</span><br><span class="line"># <span class="number">2.</span>可以使用覆盖索引</span><br><span class="line">explain <span class="keyword">select</span> job <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> job <span class="keyword">like</span> <span class="string">'%ligoudan%'</span>;</span><br></pre></td></tr></tbody></table></figure></li><li><p>查询的数据类型要正确</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可以使用create_date上的索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_date <span class="operator">&gt;=</span> now();</span><br><span class="line"># 数据类型错误，使用不了索引</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_date <span class="operator">&gt;=</span> <span class="string">'2020-05-01 00:00:00'</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>最左原则：</strong>在 InnoDB 中联合索引只有<strong>先确定了前一个（左侧的值）后，才能确定下一个值</strong>。</li><li><strong>范围查询：</strong>如果有范围查询的话，那么联合索引中使用<strong>范围查询的字段后</strong>的索引在该条 SQL 中都不会起作用。</li><li><strong>Mysql优化器：</strong>值得注意的是，<code>in</code> 和 <code>=</code> 都<strong>可以乱序</strong>。<br>比如有索引（a,b,c），语句 <code>select * from t where c =1 and a=1 and b=1</code>，<br>这样的语句也可以用到最左匹配，因为 MySQL 中有一个<strong>优化器</strong>，他会分析 SQL 语句，将其优化成索引可以匹配的形式。<br>即 <code>select * from t where a =1 and a=1 and c=1</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;联合索引了解不，最左侧匹配原则是啥？&quot;&gt;&lt;a href=&quot;#联合索引了解不，最左侧匹配原则是啥？&quot; class=&quot;headerlink&quot; title=&quot;联合索引了解不，最左侧匹配原则是啥？&quot;&gt;&lt;/a&gt;联合索引了解不，最左侧匹配原则是啥？&lt;/h1&gt;&lt;hr&gt;
&lt;blo</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="https://songx64.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴笔试题2021/06/04场</title>
    <link href="https://songx64.github.io/2021/06/04/20210604%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%95/"/>
    <id>https://songx64.github.io/2021/06/04/20210604%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%95/</id>
    <published>2021-06-04T14:52:41.000Z</published>
    <updated>2021-06-27T04:19:45.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里巴巴笔试题2021-06-04场"><a href="#阿里巴巴笔试题2021-06-04场" class="headerlink" title="阿里巴巴笔试题2021/06/04场"></a>阿里巴巴笔试题2021/06/04场</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>共有两道编程题。</p><p>采用牛客网，ACM模式，需要自己手写输入输出。</p><p>可以采用本地IDE，我用的IDEA。</p><p>会后台录屏，开摄像头，手机扫码监控后在小程序界面不能切屏（如果我有俩手机那他是不是也没办法……）</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604205103607.png" alt="考试须知"></p><p>放几个官方说明，如果不了解<strong>牛客网的ACM模式</strong>的话可以先看一下：</p><blockquote><p><a href="https://www.nowcoder.com/discuss/92224">牛客在线笔试常见问题_猿生活_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/discuss/276">牛客网在线判题系统使用帮助_站内公告_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/discuss/8050">oj的java输入hasNext和hasNextLine区别_技术交流_牛客网 (nowcoder.com)</a></p><p><a href="https://www.nowcoder.com/questionTerminal/dae9959d6df7466d9a1f6d70d6a11417">a+b__ACM模式练习</a></p></blockquote><p>接下来就是2021/06/04的两道编程题复盘。</p><p>自己第一道题用例都通过了，第二道题只过了20%。总体感觉难度不算难？主要是自己太菜了。</p><ul><li>第一道题貌似是数学题/脑筋急转弯。。。或者有更高深的说法我不知道。</li><li>第二道题就是图的遍历，其中边是带权重的。</li></ul><h2 id="1-小区划分"><a href="#1-小区划分" class="headerlink" title="1. 小区划分"></a>1. 小区划分</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>目前没有在网上找到原题与题解。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204057854.png" alt="题目描述"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204207607.png" alt="输入输出描述"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204343825.png" alt="示例1"></p><h3 id="自己思路"><a href="#自己思路" class="headerlink" title="自己思路"></a>自己思路</h3><p>下面是我的解法，思路很简单，从给的示例里看出来的。</p><p>要使得俩小区平均价值最大，那么肯定找最高的鸭，排序，从大到小。</p><p>然后<strong>钱多人少</strong>的放在一个小区，<strong>钱多人也多</strong>的放在一个小区。</p><ul><li><p>钱多人少，这样平均财富值肯定高鸭，传说中的高档小区；</p></li><li><p>钱不够那就人来凑呗，勉强也能搞点财富值，算是个中档小区吧；</p></li></ul><p>总结一下核心思路如下：</p><ol><li>首先就是先排序，从大到小；</li><li>之后再选，钱最多的几个人，放在人数少的第一个小区里；</li><li>然后再选，钱很多但没有那么多的几个人，放在人数多的第二个小区里。剩下的人就可以拜拜了（没钱买房子的就是我TAT）</li></ol><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p>代码（个人习惯把题目写道注释里了）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 住小区问题</span></span><br><span class="line"><span class="comment">     * n个人，每个人有个财富值 a[i]</span></span><br><span class="line"><span class="comment">     * 两个小区,分别住 n1 和 n2 个人</span></span><br><span class="line"><span class="comment">     * 两个小区的平均财富值尽可能大</span></span><br><span class="line"><span class="comment">     * 小区人口财富总和 / 总人数</span></span><br><span class="line"><span class="comment">     * 第一行：n,n1,n2</span></span><br><span class="line"><span class="comment">     * 共n个人，第一个小区n1，第二个小区n2</span></span><br><span class="line"><span class="comment">     * 第二行：每个人的财富值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 例子：</span></span><br><span class="line"><span class="comment">     * 4 2 1</span></span><br><span class="line"><span class="comment">     * 1 4 2 3</span></span><br><span class="line"><span class="comment">     * out:</span></span><br><span class="line"><span class="comment">     * 6.500000 (结果保留6位有效小数)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 6.5 = (2+3)/2 + 4/1</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()){</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n1 = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> n2 = in.nextInt();</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;Integer&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">                a.add(in.nextInt());</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Collections.sort(a);</span><br><span class="line">            Collections.reverse(a);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;Integer&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; a2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个小区</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(n1, n2); i++) {</span><br><span class="line">                a1.add(a.get(i));</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 第二个小区</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(n1, n2); i &lt; Math.max(n1, n2)+Math.min(n1,n2); i++) {</span><br><span class="line">                a2.add(a.get(i));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Double res = <span class="number">0.00000</span>;</span><br><span class="line">            Double tempSum = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a1.size(); i++) {</span><br><span class="line">                tempSum += Double.valueOf(a1.get(i));</span><br><span class="line">            }</span><br><span class="line">            res = Double.valueOf(tempSum/a1.size());</span><br><span class="line">            tempSum = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a2.size(); i++) {</span><br><span class="line">                tempSum += Double.valueOf(a2.get(i));</span><br><span class="line">            }</span><br><span class="line">            res += Double.valueOf(tempSum/a2.size());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"a1"</span>+a1.toString());</span><br><span class="line">            System.out.println(<span class="string">"a2"</span>+a2.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(res.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后还有个幺蛾子，就是自己打印的调试信息里，倒数两个 <code>System.out.println</code> 忘了删除，导致第一次调试没通过。。。</p><p>然后删了就可以了，直接通过全部用例。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204505603.png" alt="通过"></p><h2 id="2-重建网络"><a href="#2-重建网络" class="headerlink" title="2. 重建网络"></a>2. 重建网络</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204551088.png" alt="题目描述"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204620677.png" alt="输入输出描述"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204651352.png" alt="示例1"></p><blockquote><p>输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 7</span><br><span class="line">4 1 3</span><br><span class="line">1 2 5</span><br><span class="line">2 3 8</span><br><span class="line">2 4 1</span><br><span class="line">3 4 4</span><br></pre></td></tr></tbody></table></figure></blockquote><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604204810072.png" alt="示例2"></p><blockquote><p>输入：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4 6 5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">1 4 2</span><br><span class="line">2 4 1</span><br><span class="line">4 3 1</span><br><span class="line">3 2 1</span><br></pre></td></tr></tbody></table></figure></blockquote><p>自己画了一下图：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604225507038.png" alt="示例1"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604225449963.png" alt="示例2"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210627121920071.png" alt="修改结果"></p><h3 id="自己思路与改进"><a href="#自己思路与改进" class="headerlink" title="自己思路与改进"></a>自己思路与改进</h3><p>图的遍历，但是不会写。</p><p>于是瞎写，用邻接矩阵数组存的。矩阵matrix这个单词也忘了怎么拼，于是瞎写了个mux。</p><p>自己最初的思路，只考虑了下面的前3步，代码只实现了前两步……果然还是太菜了。</p><ol><li>存入邻接矩阵</li><li>遍历邻接矩阵，如果两个点之间的边小于最小速度，修改其权重，并将 <code>最小速度-权重</code> 加入结果</li><li>还要进行进一步的判断，如果这两个点之间，已经存在一条路径，而且路径的权重均大于最小速度，那么这个就不需要计算了</li><li>进一步思考，如果存在<strong>多条路径</strong>，而且这几条路径上，都有几条边不满足最小速度，则要进行计算比较：<br>选择变化最小，也就是其选择 <code>最小速度*路径中的边条数 - 路径权重之和</code> 的路径，修改其每条边的值，并加入结果</li></ol><p>注意，我这里说的路径是是包含多条边的，而边只是两点之间的一条边。</p><h3 id="自己代码-错误，仅通过20-测试用例"><a href="#自己代码-错误，仅通过20-测试用例" class="headerlink" title="自己代码 (错误，仅通过20%测试用例)"></a>自己代码 (错误，仅通过20%测试用例)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * n节点，m条边</span></span><br><span class="line"><span class="comment">     * 每条边有个网络速度 w_i</span></span><br><span class="line"><span class="comment">     * 删掉 m-(n-1) 条边</span></span><br><span class="line"><span class="comment">     * 任意两点有且仅有一条简单路径</span></span><br><span class="line"><span class="comment">     * 网络最低速度要等于k</span></span><br><span class="line"><span class="comment">     * 可以调节一些边的网络速度，每一次操作，可以把网络速度+1或者-1</span></span><br><span class="line"><span class="comment">     * 问：最少需要的操作次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 保证给出的是连通图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第一行：n,m,k</span></span><br><span class="line"><span class="comment">     * n条边，m个节点，k网络速度最低</span></span><br><span class="line"><span class="comment">     * 每行：u_i, v_i , w_i</span></span><br><span class="line"><span class="comment">     * 节点 u 到 v 的一条速度为 w_i 的双向边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     * sum，最少操作次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (in.hasNextInt()){</span><br><span class="line">            <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> k = in.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 邻接矩阵</span></span><br><span class="line">            <span class="keyword">int</span>[][] mux = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">                <span class="keyword">int</span> v1 = in.nextInt();</span><br><span class="line">                <span class="keyword">int</span> v2 = in.nextInt();</span><br><span class="line">                <span class="keyword">int</span> w = in.nextInt();</span><br><span class="line"></span><br><span class="line">                mux[v1-<span class="number">1</span>][v2-<span class="number">1</span>] = w;</span><br><span class="line">                mux[v2-<span class="number">1</span>][v1-<span class="number">1</span>] = w;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mux.length; i++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; mux[i].length; j++) {</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(mux[i][j] !=<span class="number">0</span>){</span><br><span class="line">                        mux[j][i] =<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (mux[i][j] &lt; k){</span><br><span class="line">                            res += (k-mux[i][j]);</span><br><span class="line">                            mux[i][j] = -<span class="number">1</span>;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"><span class="comment">//                    System.out.print(mux[i][j]+" ");</span></span><br><span class="line">                }</span><br><span class="line"><span class="comment">//                System.out.println();</span></span><br><span class="line">            }</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210604222620183.png" alt="20%通过"></p><p>感觉这20%的case，应该都是多条路径中，只更改直接相连的那条边的情况，省去了我上面说的比较的步骤。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><del>貌似可以用回溯算法解决？</del></p><p>暂时还没写出代码来。</p><hr><p>6.27：淦，这不就是最小生成树算法的改版？这里应该叫最大生成树。</p><blockquote><p><a href="https://www.cnblogs.com/wuxiangnong/p/10885129.html">图的最小生成树 - 智者侬哥 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阿里巴巴笔试题2021-06-04场&quot;&gt;&lt;a href=&quot;#阿里巴巴笔试题2021-06-04场&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴笔试题2021/06/04场&quot;&gt;&lt;/a&gt;阿里巴巴笔试题2021/06/04场&lt;/h1&gt;&lt;h2 id=&quot;简</summary>
      
    
    
    
    <category term="算法" scheme="https://songx64.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://songx64.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾收集器</title>
    <link href="https://songx64.github.io/2021/05/31/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://songx64.github.io/2021/05/31/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2021-05-31T08:59:39.000Z</published>
    <updated>2021-06-06T01:39:21.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《Offer来了-Java基础篇》第1.8章</p></blockquote><h3 id="1-8垃圾收集器"><a href="#1-8垃圾收集器" class="headerlink" title="1.8垃圾收集器"></a>1.8垃圾收集器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">subgraph 新生代 </span><br><span class="line">n(新生代)---1(Serial:单线程复制算法)</span><br><span class="line">n---2(ParNew:多线程复制算法)</span><br><span class="line">n---3(Parallel Scavenge:多线程复制算法)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph 老年代 </span><br><span class="line">老年代---CMS(CMS:多线程标记清除算法)</span><br><span class="line">老年代---SO(Serial Old:单线程标记整理算法)</span><br><span class="line">老年代---PO(Parallel Old:多线程标记整理算法)</span><br><span class="line">老年代---GI(GI:多线程表标记整理算法)</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="1-8-1-Serial收集器"><a href="#1-8-1-Serial收集器" class="headerlink" title="1.8.1 Serial收集器"></a>1.8.1 Serial收集器</h4><p>单线程</p><p>停止所有其他线程，Stop The World（Dio表示很赞，砸瓦鲁多），只启用GC线程。</p><ul><li>新生代：复制算法</li><li>老年代：标记-整理算法</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/46873026.png" alt=" Serial 收集器 "></p><ul><li>优点：没有线程交互开销，简单而高效</li><li>缺点：体验太差了。。。</li><li>是JVM在Client模式下新生代的默认收集器</li></ul><h4 id="1-8-2-ParNew收集器"><a href="#1-8-2-ParNew收集器" class="headerlink" title="1.8.2 ParNew收集器"></a>1.8.2 ParNew收集器</h4><p>多线程版本的Serial收集器</p><ul><li>新生代：复制算法</li><li>老年代：标记-整理算法</li></ul><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/22018368.png" alt="ParNew 收集器 "></p><ul><li>也会暂停其他所有线程</li><li>是JVM在Server模式下新生代的默认收集器</li><li>除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作</li></ul><blockquote><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><p>这里补充的是说GC和用户线程的并行并发（这里说的有点模糊，没太搞清）：</p><ul><li>并行：GC并行，用户暂停；</li><li>并发：GC与用户同时发生，可能交替执行；</li></ul><p>操作系统/线程里的并行并发是如下：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/1628624-20190505161932608-1136050215.jpg" alt="并行与并发"></p><p><strong>并行（Parallel）</strong>：同时做，不暂停。打个比方，一边吃饭一边打电话，你真行。</p><p><strong>并发（Concurrent）</strong>：同时发生，但是不一定同时做。打个比方，开始吃饭的时候突然来了电话，吃饭和电话同时发生，我吃一口饭说一句话，吃饭和说话不同时进行但是好像在同时进行。</p></blockquote><h4 id="1-8-3-Parallel-Scavenge收集器"><a href="#1-8-3-Parallel-Scavenge收集器" class="headerlink" title="1.8.3 Parallel Scavenge收集器"></a>1.8.3 Parallel Scavenge收集器</h4><p>与ParNew几乎一样，但是注重的是不同方面。</p><p><strong>是JDK1.8的默认收集器。</strong></p><ul><li><strong>Parallel Scavenge 收集器关注点是==吞吐量（高效率的利用 CPU）==</strong></li><li><strong>CMS 等垃圾收集器的关注点更多的是用户线程的==停顿时间（提高用户体验）==</strong></li></ul><p><strong>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值：$ CPU吞吐量 = {运行用户代码时间 \over 总消耗时间} $</strong> </p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520174914336.png" alt="ParallelScavege"></p><ul><li>新生代：复制算法</li><li>老年代：标记-整理算法</li></ul><blockquote><p>Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p></blockquote><h4 id="1-8-4-Serial-Old收集器"><a href="#1-8-4-Serial-Old收集器" class="headerlink" title="1.8.4 Serial Old收集器"></a>1.8.4 Serial Old收集器</h4><p>单线程Serial的老年代版本。</p><p>标记-整理算法。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/46873026.png" alt=" 和Serial 收集器相似 "></p><ul><li>JDK1.5以前版本，Serial Old + Parallel</li><li>CMS的后备方案</li></ul><h4 id="1-8-5-Parallel-Old-收集器"><a href="#1-8-5-Parallel-Old-收集器" class="headerlink" title="1.8.5 Parallel Old 收集器"></a>1.8.5 Parallel Old 收集器</h4><p>Parallel Scavenge的老年代版本。</p><p>多线程，标记-整理算法。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520174914336.png" alt="和ParallelScavege相似"></p><p><strong>注重吞吐量和CPU资源的场景</strong>可以使用<code>Parallel Scavenge 和 Parallel Old</code>。</p><h4 id="1-8-6-CMS收集器"><a href="#1-8-6-CMS收集器" class="headerlink" title="1.8.6 CMS收集器"></a>1.8.6 CMS收集器</h4><p>针对老年代的收集器，目的是尽量缩短停顿时间。</p><blockquote><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p></blockquote><p>CMS：Concurrent Mark Sweep，<strong>并发-标记-清除</strong>，所以说是标记-清除算法。</p><p>其稍微复杂些，分为4个步骤</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520192812031.png" alt="CMS收集器"></p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> <strong>同时开启 GC 和用户线程</strong>，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构<strong>并不能保证包含当前所有的可达对象</strong>。因为用户线程可能会<strong>不断的更新引用域</strong>，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会<strong>跟踪记录这些发生引用更新的地方</strong>。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对GC Roots不可达对象做清扫。</li></ul><p>主要优点：<strong>并发收集、低停顿</strong>。</p><p>但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h4 id="1-8-7-G1垃圾收集器"><a href="#1-8-7-G1垃圾收集器" class="headerlink" title="1.8.7 G1垃圾收集器"></a>1.8.7 G1垃圾收集器</h4><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>首先将堆内存划分为几个独立区域，然后q后台维护一个优先级列表，首先回收优先级高的，垃圾最多的内存区域。</p><p>对CMS的主要改进：</p><ul><li>基于标记-整理算法，不会产生内存碎片</li><li>可以预测的停顿，精确控制停顿时间，不牺牲吞吐量的前提下实现短停顿。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;《Offer来了-Java基础篇》第1.8章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-8垃圾收集器&quot;&gt;&lt;a href=&quot;#1-8垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;1.8垃圾收集器&quot;&gt;&lt;/a&gt;1.8垃圾</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="JVM" scheme="https://songx64.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型整理</title>
    <link href="https://songx64.github.io/2021/05/31/Java%E6%B3%9B%E5%9E%8B%E6%95%B4%E7%90%86/"/>
    <id>https://songx64.github.io/2021/05/31/Java%E6%B3%9B%E5%9E%8B%E6%95%B4%E7%90%86/</id>
    <published>2021-05-31T04:26:27.000Z</published>
    <updated>2021-06-26T12:21:53.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h1><p>面试题：泛型的考点，问题我不太记得了，还是想 &lt; Integer&gt; 和 &lt; String&gt; 的对象是否相等</p><blockquote><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=java-%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F">Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？ (gitee.io)</a></p><p><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 - little fat - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/sunxianghuang/article/details/51982979">Java泛型深入理解_void-CSDN博客_java泛型</a></p><p><a href="https://www.zhihu.com/question/20400700">Java 泛型  中 super 怎么 理解？与 extends 有何不同？ - 知乎 (zhihu.com)</a></p></blockquote><p>需要了解的：</p><ul><li>Java泛型作用，使用</li><li>类型擦除</li><li>通配符，父类子类上下边界</li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本质：<strong>参数化类型</strong>，也就是将数据类型变成一个<strong>参数</strong></p><p>Java的泛型是<strong>伪泛型</strong>，因为在编译期间所有的泛型信息都会被擦掉，也就是<strong>类型擦除</strong>。</p><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p><strong>泛型只在编译阶段有效</strong>。看下面的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList)){</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：<code>D/泛型测试: 类型相同</code>。</p><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。<strong>在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加==类型检查和类型转换的方法==。</strong>也就是说，泛型信息不会进入到运行时阶段。</p><p>对此总结成一句话：<strong>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型</strong>。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般有三种使用方式：泛型类，泛型接口，泛型方法。</p><p>泛型的类型参数只能是类类型，不能是简单类型。</p><h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1. 泛型类"></a>1. 泛型类</h3><p>类声明</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T可以使用任意标识，见下面</span></span><br><span class="line"><span class="comment">// 实例化泛型类的时候，必须指定T具体类型</span></span><br><span class="line"><span class="comment">// 类名&lt;泛型&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造，set，get等</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类实例化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; g = <span class="keyword">new</span> Generic&lt;Integer&gt;();</span><br></pre></td></tr></tbody></table></figure><h3 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2. 泛型接口"></a>2. 泛型接口</h3><p>其实和泛型类差不多啦。</p><p>接口声明：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接口实现，可以<strong>不指定类型</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接口实现，<strong>指定类型</strong>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意：这里实现类中的 T，与接口中的 T 不是同一个了，原来接口中的T在这都变成 <code>String</code> 了。</p><h3 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3. 泛型方法"></a>3. 泛型方法</h3><p>方法声明：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(E e : inputArray){</span><br><span class="line">        System.out.printf(<span class="string">"%s"</span>,e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>方法使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };</span><br><span class="line">String[] stringArray = { <span class="string">"Hello"</span>, <span class="string">"World"</span> };</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></tbody></table></figure><p>需要注意的几点：</p><ul><li>只有在返回类型之前声明了 <code>&lt;T&gt;</code> 的才是泛型方法</li><li>静态方法无法访问类上定义的泛型，如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 </li></ul><p>举例：</p><p>只有在返回类型之前声明了 <code>&lt;T&gt;</code> 的才是泛型方法！其余的都不是。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>{     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>{</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container){</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        }</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常见通配符"><a href="#常见通配符" class="headerlink" title="常见通配符"></a>常见通配符</h2><ul><li>？ 不确定的Java类型</li><li>T (type) 具体的一个Java类型</li><li>K V (key,value) 代表Java键值中的 Key 与 Value</li><li>E (element) 代表 Element</li></ul><h3 id="泛型限定通配符-上下边界"><a href="#泛型限定通配符-上下边界" class="headerlink" title="泛型限定通配符/上下边界"></a>泛型限定通配符/上下边界</h3><ul><li>限定通配符：<ul><li>上边界：<code>&lt;? extends Number&gt;</code> ，只能是 <code>Number</code> 的子类<br><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210531113912914.png" alt="上边界extends"></li><li>下边界：<code>&lt;? super Integer&gt;</code>，只能是 <code>Integer</code> 的父类<br><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210531113836697.png" alt="下边界super"></li></ul></li><li>非限定通配符：<code>&lt;?&gt;</code> 代表所有类型</li></ul><p>举例：</p><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型：</p><p>声明：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>{</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> Generic&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> Generic&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);</span><br></pre></td></tr></tbody></table></figure><p>上下边界要添加在声明上，而不是参数上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>{</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="泛型通配符-？"><a href="#泛型通配符-？" class="headerlink" title="泛型通配符 ？"></a>泛型通配符 <code>？</code></h3><p><code>Integer</code> 是 <code>Number</code> 的一个子类</p><p>泛型类 <code>Generic&lt;Integer&gt;</code> 是 <code>Generic&lt;Number&gt;</code> 的子类吗？能用 <code>Generic&lt;Integer&gt;</code> 传入 <code>Generic&lt;Number&gt;</code> 吗？</p><p>答案是不行的。</p><p>首先声明一个泛型方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>{</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p> 然后进行 Integer 与 Number 的测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue(gInteger)这里编译器会为我们报错：Generic&lt;java.lang.Integer&gt; cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>那么要怎么才能让 <code>showKeyValue(gNumber)</code> 和 <code>showKeyValue(gInteger)</code> 都不报错呢？</p><p>答案是使用通配符 <code>?</code> ，将参数改为 <code>Generic&lt;?&gt; obj</code> 即可：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>{</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类型通配符一般是使用 <code>?</code> 代替具体的<strong>类型实参</strong>。</p><p>注意了，此处 <code>?</code> 是类型实参，而不是类型形参。</p><p>再直白点的意思就是，此处的 <code>？</code> 和Number、String、Integer一样<strong>都是一种实际的类型</strong>，可以把 <code>？</code> 看成所有类型的父类，是一种真实的类型。</p><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li><p>Java中的泛型是什么 ? 使用泛型的好处是什么?<br>泛型是一种参数化类型的机制。它可以使得<strong>代码适用于各种类型</strong>，从而编写更加通用的代码，例如集合框架。</p><p>泛型是一种<strong>编译时类型确认</strong>机制。它提供了<strong>编译期的类型安全</strong>，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，<strong>避免了在运行时出现ClassCastException</strong>。</p></li></ol><p>2、Java的泛型是如何工作的 ? 什么是类型擦除 ?</p><p>​    泛型的正常工作是依赖编译器在<strong>编译源码的时候</strong>，先进行<strong>类型检查</strong>，然后进行<strong>类型擦除</strong>并且在类型参数出现的地方<strong>插入强制转换</strong>的相关指令实现的。</p><p>​    编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。<strong>例如 <code>List&lt;String&gt;</code> 在运行时仅用一个List类型来表示。</strong>为什么要进行擦除呢？这是为了避免类型膨胀。</p><ol start="3"><li><p>什么是泛型中的限定通配符和非限定通配符 ?<br>限定通配符对类型进行了限制。</p><ul><li>两种<strong>限定通配符</strong><ul><li><code>&lt;? extends T&gt;</code>它通过确保类型必须是T的子类来设定类型的<strong>上界</strong></li><li><code>&lt;? super T&gt;</code>它通过确保类型必须是T的父类来设定类型的<strong>下界</strong>。<br>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</li></ul></li><li>另一方面<code>&lt;?&gt;</code>表示了<strong>非限定通配符</strong>，因为<code>&lt;?&gt;</code>可以用<strong>任意类型</strong>来替代。</li></ul></li><li><p>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</p></li><li><p>如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?</p></li><li><p>Java中如何使用泛型编写带有参数的类?</p></li><li><p>编写一段泛型程序来实现LRU缓存?</p></li><li><p>你可以把 <code>List&lt;String&gt;</code> 传递给一个接受 <code>List&lt;Object&gt;</code> 参数的方法吗？</p></li><li><p>Array中可以用泛型吗?<br><strong>Array不支持泛型，而List支持</strong>。List可以提供编译期的类型安全保证，而Array却不能。</p></li><li><p>如何阻止Java中的类型未检查的警告?<br>如果你把<strong>泛型和原始类型混合起来使用</strong>，例如下列代码，Java 5的javac编译器会产生类型未检查的警告<br>，例如 <code> List&lt;String&gt; rawList = new ArrayList()</code><br>注意: Hello.java使用了<strong>未检查或称为不安全的操作</strong>;<br>这种警告可以使用 <code>@SuppressWarnings("unchecked")</code> <strong>注解</strong>来屏蔽。</p></li><li><p>Java中 <code>List&lt;Object&gt;</code> 和原始类型 List 之间的区别?</p><ol><li>原始类型和带参数类型<code>&lt;Object&gt;</code>之间的主要区别是，在编译时编译器<strong>不会对原始类型进行类型安全检查，却会对带参数的类型进行检查</strong>，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。这道题的考察点在于对泛型中原始类型的正确理解。</li><li>它们之间的第二点区别是，你可以把<strong>任何带参数的泛型类型传递给接受原始类型List的方法</strong>，但却不能把<code>List&lt;String&gt;</code>传递给接受<code>List&lt;Object&gt;</code>的方法，因为会产生编译错误。</li></ol></li><li><p><code>Java中List&lt;?&gt;</code>和 <code>List&lt;Object&gt;</code> 之间的区别是什么?<br>这道题跟上一道题看起来很像，实质上却完全不同。<br><code>List&lt;?&gt; </code>是一个<strong>所有类型的List</strong>，而<code>List&lt;Object&gt;</code>其实是<strong>Object类型的List</strong>。<br>你可以把<code>List&lt;String&gt;, List&lt;Integer&gt;</code>赋值给<code>List&lt;?&gt;</code>，却不能把<code>List&lt;String&gt;</code>赋值给<code>List&lt;Object&gt;</code>。   </p></li></ol><pre><code>`List&lt;Object&gt;` 与 `List&lt;?&gt;` 并不等同，`List&lt;Object&gt;` 是`List&lt;?&gt;`的子类。还有不能往`List&lt;?&gt; list`里添加任意对象，除了null。</code></pre><ol start="13"><li><p><code>List&lt;String&gt;</code>和原始类型List之间的区别.<br>该题类似于“11. 原始类型和带参数类型之间有什么区别”。<br><strong>带参数类型是类型安全</strong>的，而且其类型安全是由<strong>编译器保证</strong>的，但<strong>原始类型List却不是类型安全的</strong>。<br>你不能把String之外的任何其它类型的Object存入String类型的List中，而你可以把任何类型的对象存入原始List中。<br>使用泛型的带参数类型你<strong>不需要进行类型转换</strong>，但是对于原始类型，你则需要进行<strong>显式的类型转换</strong>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List listOfRawTypes = <span class="keyword">new</span> ArrayList();</span><br><span class="line">listOfRawTypes.add(<span class="string">"abc"</span>);</span><br><span class="line">listOfRawTypes.add(<span class="number">123</span>); <span class="comment">//编译器允许这样 - 运行时却会出现异常</span></span><br><span class="line">String item = (String) listOfRawTypes.get(<span class="number">0</span>); <span class="comment">//需要显式的类型转换</span></span><br><span class="line">item = (String) listOfRawTypes.get(<span class="number">1</span>); <span class="comment">//抛ClassCastException，因为Integer不能被转换为String</span></span><br><span class="line">      </span><br><span class="line">List&lt;String&gt; listOfString = <span class="keyword">new</span> ArrayList();</span><br><span class="line">listOfString.add(<span class="string">"abcd"</span>);</span><br><span class="line">listOfString.add(<span class="number">1234</span>); <span class="comment">//编译错误，比在运行时抛异常要好</span></span><br><span class="line">item = listOfString.get(<span class="number">0</span>); <span class="comment">//不需要显式的类型转换 - 编译器自动转换</span></span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java泛型&quot;&gt;&lt;a href=&quot;#Java泛型&quot; class=&quot;headerlink&quot; title=&quot;Java泛型&quot;&gt;&lt;/a&gt;Java泛型&lt;/h1&gt;&lt;p&gt;面试题：泛型的考点，问题我不太记得了，还是想 &amp;lt; Integer&amp;gt; 和 &amp;lt; String&amp;</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hexo部署至阿里云服务器的问题</title>
    <link href="https://songx64.github.io/2021/05/29/Hexo%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://songx64.github.io/2021/05/29/Hexo%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-05-29T14:31:35.000Z</published>
    <updated>2021-06-06T01:39:21.167Z</updated>
    
    <content type="html"><![CDATA[<p>写到这里才发现我有多傻。服务器上，貌似只要安装git和Nginx就可以了？？？</p><p>写一下部署的主要步骤吧：</p><ol><li>安装NodeJS</li><li>安装Git</li><li>安装 hexo , hexo-cli, hexo-deploy-git（这里好像在服务器上没有必要？）</li><li>安装Nginx</li><li>新建空仓库，配置用户</li><li>客户端修改hexo文件夹下的配置</li><li>Nginx转发到git的静态文件夹中就可以了</li></ol><hr><p>多灾多难，瞎几把搞。</p><p>因为经历了太多所以说没能太仔细整理。简单记录一下吧。</p><blockquote><p> 参考教程：</p><p><a href="https://developer.aliyun.com/article/775005">记录Hexo部署到阿里云服务器全过程-阿里云开发者社区 (aliyun.com)</a></p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">hexo-theme-matery/README_CN.md</a></p></blockquote><p>因为不是很会用Linux，所以说搞出了不少幺蛾子，整了大半天。。。</p><p>主要包括但不限于以下问题：</p><ul><li>NodeJS版本过低</li><li>NodeJS安装编译失败</li><li>NodeJS链接创建后仍然找不到node命令</li><li>hexo因为缺少npm组件生成失败</li><li>忘了安装hexo-deploy-git和hexo-cli</li><li>Nginx转发静态资源失败</li></ul><p>尝试过:</p><ul><li><p>安装node的未编译版本与编译版本</p><ul><li>未编译版本，升级gcc与gcc-c++从版本4到8，仍然编译失败</li><li>编译版本，开始用<code>v6.几</code>的版本，然后版本过低， <code>hexo g</code> 命令生成失败</li><li>之后改用 <code>v15</code>版本，可能是太新了？又改用稳定版本，<code>v14.17.0</code>，参考官方文档安装，终于成了<br><a href="https://github.com/nodejs/help/wiki/Installation">Installation   nodejs/help </a><br>主要就是下载，解压，然后添加export语句到 <code>/etc/profile</code> 文件下。之前一堆教程乱七八糟的不知道咋整的，编译失败，创建链接之类的都不管用。</li></ul></li><li><p>贴一下Nginx配置文件：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">user  root;</span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">location / {</span><br><span class="line">            root /home/git/projects/blog;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">        error_page  <span class="number">404</span>              /<span class="number">404.</span>html;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>开始出现了403禁止问题，于是改了第一行的<code>user root</code>就可以了。</p></li></ul><p>hexo主题安装的npm组件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索插件</span></span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line"><span class="meta">#</span><span class="bash"> 汉字链接转拼音</span></span><br><span class="line">npm i hexo-permalink-pinyin --save</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字数统计</span></span><br><span class="line">npm i --save hexo-wordcount </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>最后gcc make的编译失败问题还是没解决，我觉得也是版本的问题。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写到这里才发现我有多傻。服务器上，貌似只要安装git和Nginx就可以了？？？&lt;/p&gt;
&lt;p&gt;写一下部署的主要步骤吧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装NodeJS&lt;/li&gt;
&lt;li&gt;安装Git&lt;/li&gt;
&lt;li&gt;安装 hexo , hexo-cli, hexo-deploy</summary>
      
    
    
    
    <category term="杂项" scheme="https://songx64.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="杂项" scheme="https://songx64.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池简单了解</title>
    <link href="https://songx64.github.io/2021/05/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://songx64.github.io/2021/05/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-05-26T15:26:10.000Z</published>
    <updated>2021-06-06T01:39:21.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java线程池简单了解"><a href="#Java线程池简单了解" class="headerlink" title="Java线程池简单了解"></a>Java线程池简单了解</h1><p>[TOC]</p><blockquote><p>主要查看文章：</p><p><a href="https://mp.weixin.qq.com/s/baYuX8aCwQ9PP6k7TDl2Ww">Java线程池实现原理及其在美团业务中的实践 </a></p><p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/%E6%8B%BF%E6%9D%A5%E5%8D%B3%E7%94%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">JavaGuide -线程池最佳实践</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485808&amp;idx=1&amp;sn=1013253533d73450cef673aee13267ab&amp;chksm=cea246bbf9d5cfad1c21316340a0ef1609a7457fea4113a1f8d69e8c91e7d9cd6285f5ee1490&amp;token=510053261&amp;lang=zh_CN&amp;scene=21#wechat_redirect">新手也能看懂的线程池学习总结</a></p></blockquote><h2 id="1-为什么要用线程池"><a href="#1-为什么要用线程池" class="headerlink" title="1.为什么要用线程池"></a>1.为什么要用线程池</h2><p>池化思想，比如线程池，数据库连接池，HTTP连接池等。主要是为了能够重复利用资源，提高资源的利用率。</p><p>线程池的好处:</p><ul><li>降低资源消耗：可重复利用资源</li><li>提高响应速度：任务到达时，无需等待线程创建即可立即执行</li><li>提高线程可管理性：防止线程创建过多消耗尽系统资源内存等</li></ul><p><strong>线程池解决的核心问题：资源管理问题</strong></p><h2 id="2-Java线程池使用例子"><a href="#2-Java线程池使用例子" class="headerlink" title="2 Java线程池使用例子"></a>2 Java线程池使用例子</h2><h3 id="2-1-总览"><a href="#2-1-总览" class="headerlink" title="2.1 总览"></a>2.1 总览</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210527114738269.png" alt="Executor使用示意图"></p><ol><li><p>主线程首先创建实现 <code>Runnable</code> 或者 <code>Callable</code> 接口的<strong>任务对象</strong></p></li><li><p><strong>把创建完成的实现 <code>Runnable</code>/<code>Callable</code>接口的对象，直接交给 <code>ExecutorService</code> 执行</strong>: </p><ul><li><code>ExecutorService.execute（Runnable command）</code></li><li><code>ExecutorService.submit（Runnable task）</code></li><li><code>ExecutorService.submit（Callable &lt;T&gt; task）</code></li></ul><p>关于 <code>submit()</code> 与 <code>execute()</code> 区别看下面。</p></li><li><p>如果使用的submit提交，则会返回Future对象，包含执行结果。</p><p><code>FutureTask = Future + Runnable</code>，可以用它来直接提交任务与获得返回结果。</p></li><li><p>主线程<code>future.get()</code>获取返回结果，或者主线程 <code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行，参数boolean表示是否让任务完成。</p></li></ol><h4 id="submit与execute"><a href="#submit与execute" class="headerlink" title="submit与execute"></a>submit与execute</h4><ol><li><p><code>execute()</code>方法用于提交<strong>不需要返回值的任务</strong>，所以<strong>无法判断</strong>任务是否被线程池执行<strong>成功与否</strong>；</p></li><li><p><code>submit()</code>方法用于提交<strong>需要返回值的任务</strong>。</p><p>线程池会返回一个 <strong><code>Future</code> 类型的对象</strong>，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</p><ul><li><p>可以通过 <code>Future</code> 的 <code>get()</code>方法来<strong>获取返回值</strong>，<code>get()</code>方法会<strong>阻塞当前线程直到任务完成</strong>；</p></li><li><p>而使用 <code>get（long timeout，TimeUnit unit）</code>方法则会<strong>阻塞当前线程一段时间后立即返回</strong>，这时候有可能任务没有执行完。</p></li></ul></li></ol><h3 id="2-2-ThreadPoolExecutor实例"><a href="#2-2-ThreadPoolExecutor实例" class="headerlink" title="2.2 ThreadPoolExecutor实例"></a>2.2 ThreadPoolExecutor实例</h3><p>==<strong>Java中的线程池：ThreadPoolExecutor</strong>==</p><p>ThreadPoolExecutor的构造函数，用它来创建线程池：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,//线程池的核心线程数量</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,//线程池的最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,//时间单位</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span></span><br><span class="line"><span class="function"><span class="params">                           )</span></span></span><br></pre></td></tr></tbody></table></figure><p>这几个参数，稍微记一下：</p><ul><li>核心线程数量</li><li>最大线程数量</li><li>存活时间（当前线程数 &gt; 核心线程数，多余线程的最长存活时间）</li><li>时间单位（TimeUnit.SECONDS）</li><li>任务队列</li><li>线程工厂，一般默认不用管</li><li>拒绝策略（任务过多时，定制策略处理任务）</li></ul><p>创建例子：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 核心线程数 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="comment">/** 最大线程数 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/** 队列容量 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line"><span class="comment">/** 最大存活时间 **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">    <span class="comment">//通过ThreadPoolExecutor构造函数，自定义参数创建</span></span><br><span class="line">    ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAX_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环，线程池中，创建10个线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="comment">// Lambda表达式，调用execute的参数类型Runnable接口的构造函数，返回匿名对象并实现其中方法（大括号中）</span></span><br><span class="line">        <span class="comment">// 相当于new Runnable(){ run(){} }</span></span><br><span class="line">        executor.execute(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"CurrentThread name:"</span> + Thread.currentThread().getName() + <span class="string">"；date："</span> + Instant.now());</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//终止线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><code>ThreadPoolExecutor</code>构造函数创建线程池</li><li>线程池中运行线程 <code>executor.execute(Runnable r)</code></li><li>终止线程池 <code>exector.shutdown()</code></li></ol><blockquote><p>其中，关于Lamda表达式-&gt;：Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>下面这个例子就是调用了一个<strong>构造函数</strong>，返回了一个新建的对象，然后传入<strong>函数参数</strong>中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventQueue.invokeLater(() -&gt; {</span><br><span class="line">      JFrame frame = <span class="keyword">new</span> ImageViewerFrame();</span><br><span class="line">      frame.setTitle(<span class="string">"ImageViewer"</span>);</span><br><span class="line">      frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">EventQueue.invokeLater(<span class="keyword">new</span> Runnable() {</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">          JFrame frame = <span class="keyword">new</span> ImageViewerFrame();</span><br><span class="line">          frame.setTitle(<span class="string">"ImageViewer"</span>);</span><br><span class="line">          frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">          frame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">      }</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure></blockquote><h2 id="3-线程池核心设计与实现总览"><a href="#3-线程池核心设计与实现总览" class="headerlink" title="3.线程池核心设计与实现总览"></a>3.线程池核心设计与实现总览</h2><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526110139152.png" alt="ThreadPoolExecutor的UML类图"></p><p>这个UML看的不是很懂。。。继续往下看</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526110421744.png" alt="ThreadPoolExecutor运行流程"></p><h2 id="4-线程池生命周期"><a href="#4-线程池生命周期" class="headerlink" title="4. 线程池生命周期"></a>4. 线程池生命周期</h2><p>其中，线程池 <code>ThreadPoolExecutor</code>的状态有5种：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526224430777.png" alt="ThreadPoolExecutor状态5种"></p><p>其状态转移图：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526224536641.png" alt="5种状态的转移"></p><h2 id="5-任务执行机制"><a href="#5-任务执行机制" class="headerlink" title="5. 任务执行机制"></a>5. 任务执行机制</h2><p>线程池的本质是对<strong>任务和线程</strong>的管理，而做到这一点==最关键的思想就是将任务和线程两者解耦==，不让两者直接关联，才可以做后续的分配工作。</p><p>线程池中是以<strong>生产者消费者模式</strong>，通过一个阻塞队列来实现的。</p><p>阻塞队列缓存任务，工作线程（消费者）从阻塞队列中获取任务。</p><p>分为以下几个模块：</p><ul><li>任务调度</li><li>任务缓冲</li><li>任务申请</li><li>任务拒绝</li></ul><h3 id="5-1-任务调度"><a href="#5-1-任务调度" class="headerlink" title="5.1 任务调度"></a><strong>5.1 任务调度</strong></h3><p>一个任务提交到线程池了之后，会经过一下判断</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526225421822.png" alt="image-20210526225421822"></p><h3 id="5-2-任务缓冲"><a href="#5-2-任务缓冲" class="headerlink" title="5.2 任务缓冲"></a><strong>5.2 任务缓冲</strong></h3><p>任务缓冲模块是线程池能够管理任务的<strong>核心部分</strong>。</p><p>线程池的本质是对<strong>任务和线程</strong>的管理，而做到这一点==最关键的思想就是将任务和线程两者解耦==，不让两者直接关联，才可以做后续的分配工作。</p><p>线程池中是以<strong>生产者消费者模式</strong>，通过一个阻塞队列来实现的。</p><p>阻塞队列缓存任务，工作线程（消费者）从阻塞队列中获取任务。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526232913936.png" alt="阻塞队列示意"></p><blockquote><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。</p><p>这两个附加的操作是：</p><ul><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。</li></ul><p>阻塞队列常用于生产者和消费者的场景：</p><ul><li>生产者是往队列里添加元素的线程</li><li>消费者是从队列里拿元素的线程</li></ul><p>阻塞队列就是生产者存放元素的<strong>容器</strong>，而消费者也只从容器里拿元素。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526230357982.png" alt="阻塞队列成员"></p></blockquote><h3 id="5-3-任务申请"><a href="#5-3-任务申请" class="headerlink" title="5.3 任务申请"></a>5.3 任务申请</h3><p>任务的执行有两种可能：</p><ul><li>一种是<strong>任务直接由新创建的线程执行</strong>（仅出现在线程初始创建的时候）</li><li>另一种是线程从<strong>任务队列中获取任务</strong>然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行（线程获取任务绝大多数的情况）</li></ul><p>线程池中的<strong>线程</strong>去<strong>申请任务</strong>的步骤：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526231424192.png" alt="线程申请任务步骤"></p><p>申请任务时，通过一个 <code>getTask()</code>去执行，经过以上判断的<strong>目的是为了防止线程池中的线程过多，控制线程数量</strong>。</p><h3 id="5-4-任务拒绝"><a href="#5-4-任务拒绝" class="headerlink" title="5.4 任务拒绝"></a>5.4 任务拒绝</h3><p>任务拒绝模块是线程池的==保护部分==。</p><p>线程池有一个<strong>最大的容量</strong>，当线程池的<strong>任务缓存队列已满</strong>，并且线程池中的<strong>线程数目达到maximumPoolSize</strong>时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p><p><code>RejectedExecutionHandler</code> 是一个<strong>接口</strong>，可以自定义拒绝策略。</p><p>也可以用JDK自带的4种拒绝策略：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210526232150795.png" alt="JDK自带的4种拒绝策略"></p><h2 id="6-使用场景举例"><a href="#6-使用场景举例" class="headerlink" title="6.使用场景举例"></a>6.使用场景举例</h2><h3 id="场景1：快速响应用户请求"><a href="#场景1：快速响应用户请求" class="headerlink" title="场景1：快速响应用户请求"></a><strong>场景1：快速响应用户请求</strong></h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210527112123842.png" alt="并行执行任务提升任务响应速度"></p><blockquote><p><strong>描述</strong>：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。</p></blockquote><p>这种场景最重要的就是获取最大的响应速度去满足用户，</p><p>所以应该<strong>不设置队列去缓冲并发任务</strong>，<strong>调高corePoolSize和maxPoolSize</strong>去<strong>尽可能创造多的线程</strong>快速执行任务。</p><h3 id="场景2：快速处理批量任务"><a href="#场景2：快速处理批量任务" class="headerlink" title="场景2：快速处理批量任务"></a><strong>场景2：快速处理批量任务</strong></h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210527112403454.png" alt="并行执行任务提升批量任务执行速度"></p><blockquote><p><strong>描述</strong>：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。</p></blockquote><p>这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。</p><p>设置<strong>队列去缓冲并发任务</strong>，调整合适的corePoolSize去设置处理任务的线程数</p><p>设置的<strong>线程数过多</strong>可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。</p><h2 id="7-几个对比"><a href="#7-几个对比" class="headerlink" title="7. 几个对比"></a>7. 几个对比</h2><ul><li>Runnable 与 Callable：前者不抛异常/返回结果，后者会</li><li>execute() 与 submit()：前者不会返回结果，后者会</li><li>shutdown() 与 shutdownNow()：前者会等待队列中的任务执行完毕，后者不会</li><li>isShutdown() 与 isTeminated() ：前者是shutdown()了之后就true，后者是等全部执行完成了之后才true</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如何回答线程池原理：</p><p>感觉只要答出，任务–线程解耦，以及阻塞队列，生产者消费者模式，就可以了，这几个是重点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java线程池简单了解&quot;&gt;&lt;a href=&quot;#Java线程池简单了解&quot; class=&quot;headerlink&quot; title=&quot;Java线程池简单了解&quot;&gt;&lt;/a&gt;Java线程池简单了解&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要查看文章：&lt;</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="多线程" scheme="https://songx64.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>B树与B+树简单了解</title>
    <link href="https://songx64.github.io/2021/05/21/B%E6%A0%91%E4%B8%8EB-%E6%A0%91%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/"/>
    <id>https://songx64.github.io/2021/05/21/B%E6%A0%91%E4%B8%8EB-%E6%A0%91%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3/</id>
    <published>2021-05-21T13:18:46.000Z</published>
    <updated>2021-06-06T01:39:21.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于B树和B-树"><a href="#关于B树和B-树" class="headerlink" title="关于B树和B+树"></a>关于B树和B+树</h4><blockquote><p>小灰算法</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190965&amp;idx=1&amp;sn=53f78fa037386f85531832cd5322d2a0&amp;chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&amp;scene=21#wechat_redirect">漫画：什么是B-树？</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191027&amp;idx=1&amp;sn=4ba22e3ec8bd149f69fc0aba72e4347e&amp;chksm=8c9909a9bbee80bfa1d8497ff0525df130414c1731b5aa5287bf16ea1cf86c8d8e6f20782184&amp;scene=21#wechat_redirect">漫画：什么是B+树？</a></p></blockquote><h5 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h5><h6 id="为什么要使用B-树"><a href="#为什么要使用B-树" class="headerlink" title="为什么要使用B-树"></a>为什么要使用B-树</h6><p>二叉查找树速度和比较次数都是最小的，但是需要考虑<strong>磁盘IO问题</strong>。</p><p><strong>数据库索引是存在磁盘上的</strong>，加载的时候不可能整个索引都加载到内存，只能逐一加载每一个磁盘页（每一个磁盘页对应一个索引树节点）。</p><p>首先假设一颗二叉查找树:</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521202605242.png" alt="二叉查找树"></p><p>其<strong>查找次数最大为树的高度</strong>，也就是要进行4次磁盘IO。</p><p><strong>将“瘦高”的树变得“矮胖”</strong>。</p><p>B树（就是B-树）主要目的是<strong>为了解决磁盘IO次数</strong>的。其中每个节点包括k个孩子，k取决于磁盘页大小。</p><p>k最大值就是k阶B树（下面这个应该是3阶B树）</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521202407286.png" alt="举例一个B树"></p><p>其改善的地方，就是<strong>每个节点都是一个磁盘页</strong>，每次加载会将这一整个节点加载到内存中。在内存中比较的速度比磁盘IO快多了。</p><h6 id="B-树插入"><a href="#B-树插入" class="headerlink" title="B-树插入"></a>B-树插入</h6><p><strong>B-树一大优势：自平衡</strong></p><p>插入过程比较麻烦，涉及到节点分裂。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521203906045.png" alt="插入4"></p><p>节点3，5已经是两元素节点，无法再增加。父亲节点 2， 6 也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是<strong>拆分</strong>节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521203927763.png" alt="节点分裂平衡"></p><h6 id="B-树删除"><a href="#B-树删除" class="headerlink" title="B-树删除"></a>B-树删除</h6><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521204113459.png" alt="删除11"></p><p>删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为<strong>左旋</strong>）</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521204158580.png" alt="B-树左旋"></p><h5 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h5><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521204828678.png" alt="B+树举例"></p><p>性质1：父节点中的元素，出现在了子节点中，而且是其中最大的；</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521204913216.png" alt="重复元素"></p><p>性质2：因为包括父节点元素，所以说叶子节点中，包括所有元素。而且连在一起成了个链表</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521205055673.png" alt="叶子节点"></p><p>卫星数据：卫星其实就是索引，一个指针，指向实际地址。下面图里的Data就是卫星数据。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521205232096.png" alt="B-树中的卫星数据"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521205255618.png" alt="B+树中的卫星数据"></p><p>在数据库的<strong>聚集索引</strong>（Clustered Index）中，叶子节点直接包含数据。MySQL中的InnoDB引擎。</p><p>在<strong>非聚集索引</strong>（NonClustered Index）中，叶子节点带有指向数据的指针。MySQL中MyISAM引擎。</p><h6 id="与B-树对比"><a href="#与B-树对比" class="headerlink" title="与B-树对比"></a>与B-树对比</h6><p>其查询：</p><p>B+树中间节点没有存储卫星数据（全在叶子节点上），所以说可以<strong>存储更多索引</strong>。IO次数更少</p><p>B+树必须查询到<strong>叶子节点</strong>，而B-树不一定。</p><p>B+树查询<strong>稳定</strong>，B-树则不是。</p><h6 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h6><p>查询分为单元素查询，和范围查询。</p><p>单元素查询比较容易理解；</p><p>而范围查询是指查询一个范围，比如“3到11”之间的所有数字。</p><p>B-树必须要去树的<strong>中序遍历</strong>；</p><p>而B+树在找到3之后，根据叶子节点的<strong>链表</strong>可以直接查询到。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210521211511367.png" alt="叶子节点链表遍历"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="B树"><a href="#B树" class="headerlink" title="B树:"></a>B树:</h5><ul><li>为了解决磁盘IO问题，使用B树。一个节点就是一个磁盘页。</li><li>B树插入与删除比较麻烦，需要节点分裂与自旋，重要特性自平衡。</li><li>MongoDB和文件系统使用B-树。</li></ul><h5 id="B-树："><a href="#B-树：" class="headerlink" title="B+树："></a>B+树：</h5><ul><li>B+树只在叶子节点中存入数据，而非叶子节点中存的只是索引。<ul><li>所以说B+树一定要查到叶子节点，稳定查询。而B树则不是。</li><li>所以说一个非叶子节点存的比B树的更多，更能解决磁盘IO问题。</li></ul></li><li>B+树子节点中包括父节点的数据，所以说叶子节点包括所有数据。</li><li>而且叶子节点之间用指针相连，形成了一个链表。做范围查询非常简单。</li></ul><h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>MySQL中B+树索引与哈希索引。</p><p>B+树索引：</p><ul><li>非聚簇索引：MySQL的MyISAM引擎，B+树节点里面存储的是索引与数据地址。</li><li>聚簇索引：MySQL的InnoDB引擎<ul><li>主索引：非叶子节点存储主键，叶子节点存储数据；</li><li>辅助索引：节点中存主键，然后再根据主索引去找。</li></ul></li></ul><p>哈希索引：</p><ul><li>MyISAM不支持</li><li>InnoDB会自动在使用频繁的数据上添加，自动在B+树索引的基础上创建一个哈希索引。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;关于B树和B-树&quot;&gt;&lt;a href=&quot;#关于B树和B-树&quot; class=&quot;headerlink&quot; title=&quot;关于B树和B+树&quot;&gt;&lt;/a&gt;关于B树和B+树&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;小灰算法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.w</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="算法" scheme="https://songx64.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据结构" scheme="https://songx64.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存区域</title>
    <link href="https://songx64.github.io/2021/05/20/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://songx64.github.io/2021/05/20/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-05-20T04:17:49.000Z</published>
    <updated>2021-06-06T01:39:21.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存区域（重要！）"><a href="#JVM内存区域（重要！）" class="headerlink" title="JVM内存区域（重要！）"></a>JVM内存区域（重要！）</h3><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520105743387.png" alt="JDK1.8之前"></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520105816189.png" alt="JDK1.8之后"></p><p>分为线程共享和线程私有的两种内存：</p><ul><li>线程私有<ul><li>程序计数器（唯一不会出现<code>OutOfMemoryError</code> 内存溢出错误的区域）</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>线程共享<ul><li>堆</li><li>方法区（1.8之后去掉改为本地内存内的元空间）<ul><li>运行时常量池</li></ul></li></ul></li><li>本地内存<ul><li>直接内存</li><li>元空间</li></ul></li></ul><p>下面详细解释一下：</p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h4><ul><li>唯一不会出现<code>OutOfMemoryError</code> 内存溢出错误的区域</li><li>记录线程的暂停与继续执行的<strong>指令</strong>行</li><li>分支/循环/跳转等流程控制</li></ul><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a><strong>虚拟机栈</strong></h4><ul><li>传递<strong>调用方法</strong>时的数据</li><li>调用方法，栈帧入栈；方法结束（返回值/异常），栈帧出栈</li><li>局部变量表：编译期可知的数据类型/对象引用</li><li>两种错误<ul><li>StackOverFlowError：JVM虚拟机栈容量不允许动态扩展</li><li>OutOfMemoryError：JVM虚拟机栈容量允许动态扩展但是超出内存</li></ul></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h4><ul><li><p>其实与JVM栈一样，不过调用的是Native本地方法</p></li><li><p>线程共享</p></li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a><strong>堆</strong></h4><ul><li>最大的一块</li><li>存放几乎所有<strong>对象实例</strong>及数组（JDK1.7之后不再那么绝对因为有<em>逃逸分析</em>）</li></ul><p>因为是垃圾回收主要负责的一块，也被称为GC堆。</p><hr><p>下面内容涉及垃圾回收的东西了。</p><p>可以根据垃圾回收继续细分：</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常被分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永生代(Permanent Generation)</li></ol><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520112423368.png" alt="JVM堆内存结构-JDK7"></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210520112606272.png" alt="元空间"></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">b[Begin]--对象创建--&gt;Eden区 --一次新生代垃圾回收仍旧存活--&gt; age[年龄+1,进入s0/s1 ]--超过阈值--&gt;进入老年代</span><br><span class="line">b--大对象--&gt;老年代</span><br><span class="line">subgraph 新生代划分</span><br><span class="line">新生代--&gt;.Eden区</span><br><span class="line">新生代--&gt;Survivor区--&gt;s0</span><br><span class="line">Survivor区--&gt;s1</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p></blockquote><ul><li>新生代<ul><li>新生代GC过程称为MinorGC，采用<strong>复制算法</strong></li></ul></li><li>老年代<ul><li>存放长生命周期对象，大对象（默认2KB~128KB)</li><li>老年代的CG过程称为MajorGC，采用<strong>标记-清除算法</strong>，不会频繁触发</li></ul></li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>（1.8之后去掉改为本地内存内的元空间）</p><p><strong>方法区</strong>其实在<strong>Hotspot虚拟机</strong>中就是<strong>永久代</strong>（1.8之前），在1.8之后就是<strong>元空间</strong>。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域。</p><p>它用于存储已被虚拟机加载的Class类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>方法区有JVM内存上限限制，元空间只有系统限制。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>JDK1.7之前，常量池全在永久代。</p><p>JDK1.7，字符串常量池在堆，运行时常量池在永久代</p><p>JDK1.8之后，字符串常量池在堆，运行时常量池在元空间。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>总结一下：</p><ul><li>线程私有<ul><li>程序计数器（流程控制，线程暂停）</li><li>虚拟机栈（栈帧，方法调用）</li><li>本地方法栈（Native方法）</li></ul></li><li>线程共享<ul><li>堆（包含字符串常量池，最大的内存区域，垃圾回收主要管理区域，存储对象/数组）</li><li>方法区（永久代，后被替换为元空间）</li><li>本地内存<ul><li>元空间（包含运行时常量池）</li><li>直接内存（系统内存）</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JVM内存区域（重要！）&quot;&gt;&lt;a href=&quot;#JVM内存区域（重要！）&quot; class=&quot;headerlink&quot; title=&quot;JVM内存区域（重要！）&quot;&gt;&lt;/a&gt;JVM内存区域（重要！）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/so</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="JVM" scheme="https://songx64.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>依赖倒置原则</title>
    <link href="https://songx64.github.io/2021/05/19/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    <id>https://songx64.github.io/2021/05/19/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</id>
    <published>2021-05-19T13:50:25.000Z</published>
    <updated>2021-06-06T01:39:21.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="依赖倒置与控制反转"><a href="#依赖倒置与控制反转" class="headerlink" title="依赖倒置与控制反转"></a>依赖倒置与控制反转</h1><blockquote><ol><li><a href="https://www.jianshu.com/p/c3ce6762257c">六大设计原则之依赖倒置原则（DIP） - 简书 (jianshu.com)</a></li><li><a href="https://www.zhihu.com/question/23277575/answer/169698662">Spring IoC有什么好处呢？ - 知乎 (zhihu.com)</a></li></ol></blockquote><h2 id="DI依赖倒置"><a href="#DI依赖倒置" class="headerlink" title="DI依赖倒置"></a>DI依赖倒置</h2><p>首先是依赖倒置原则：</p><blockquote><p>1、上层模块不应该依赖底层模块，它们都应该依赖于抽象。<br>2、抽象不应该依赖于细节，细节应该依赖于抽象。</p></blockquote><p>举例：pizza店</p><p>无依赖倒置：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/9571610-1970cb0205d4a656.png" alt="依赖关系"></p><p>有依赖倒置：</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/9571610-9917220623b99e19.png" alt="依赖倒置"></p><p>可以看出，上层的Pizza店依赖于抽象的接口Pizza，而不是直接依赖下层的细节实现对象。</p><p>总结：</p><ul><li>上层依赖抽象</li><li>细节依赖抽象</li></ul><h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><p>其次，控制反转，依赖注入是实现依赖倒置的一种方法。</p><p><img src="https://pic1.zhimg.com/v2-ee924f8693cff51785ad6637ac5b21c1_r.jpg?source=1940ef5c" alt="IOC与DI"></p><ul><li><p>依赖倒置原则，控制反转IOC，依赖注入DI</p></li><li><p>降低耦合</p></li><li><p>不用在上层类中调用下层的构造函数，而是直接将下层的对象构造好了之后传入上层类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>{</span><br><span class="line">    <span class="keyword">private</span> Framework f;</span><br><span class="line">    Car(){</span><br><span class="line">        <span class="comment">// 如果下层的FrameWork类变动，需要传入参数，这个上层的Car类也需要改</span></span><br><span class="line">        <span class="keyword">this</span>.f = <span class="keyword">new</span> FrameWork();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>修改使用依赖倒置后，会变成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>{</span><br><span class="line"> <span class="keyword">private</span> FrameWork f;</span><br><span class="line">    <span class="comment">// 这样直接传入下层类对象过来就行了，而不需要具体关心其实现</span></span><br><span class="line">    Car(FrameWork f){</span><br><span class="line">        <span class="keyword">this</span>.f = f;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>上面是构造方法传入，还有Set传递和接口传递</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;依赖倒置与控制反转&quot;&gt;&lt;a href=&quot;#依赖倒置与控制反转&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置与控制反转&quot;&gt;&lt;/a&gt;依赖倒置与控制反转&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ji</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot常用注解</title>
    <link href="https://songx64.github.io/2021/05/15/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <id>https://songx64.github.io/2021/05/15/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-15T10:02:40.000Z</published>
    <updated>2021-06-06T01:39:21.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot常用注解"><a href="#Spring-Boot常用注解" class="headerlink" title="Spring Boot常用注解"></a>Spring Boot常用注解</h1><p>自己重新整理一下吧。</p><ol><li><p>首先是最常见的，请求路径相关的，主要就是Mapping：</p><ul><li><p>@RequestMapping：一个用来处理请求地址映射的注解，可用于<strong>类或方法</strong>上。用于类上，表示类中的所有响应请求的方法都是以该地址作为<strong>父路径</strong>；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/notice")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysNoticeController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@PostMapping：新建，insert数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">add</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> SysNotice notice)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    notice.setCreateBy(SecurityUtils.getUsername());</span><br><span class="line">    <span class="keyword">return</span> toAjax(noticeService.insertNotice(notice));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@GetMapping：获取，select数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("/list")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TableDataInfo <span class="title">list</span><span class="params">(SysNotice notice)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    startPage();</span><br><span class="line">    List&lt;SysNotice&gt; list = noticeService.selectNoticeList(notice);</span><br><span class="line">    <span class="keyword">return</span> getDataTable(list);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@PutMapping：修改，update数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">edit</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> SysNotice notice)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    notice.setUpdateBy(SecurityUtils.getUsername());</span><br><span class="line">    <span class="keyword">return</span> toAjax(noticeService.updateNotice(notice));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@DeleteMapping：删除，delete数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping("/{noticeIds}")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long[] noticeIds)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> toAjax(noticeService.deleteNoticeByIds(noticeIds));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>其次是各个层次的，标明这个类属于什么类型的：</p><ul><li><p>@SpringBootApplication：启动类，是个组合注解，里面包括@Configuration，@EnableAutoConfiguration，@ComponentScan等</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication {……}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@Controller：返回一整个页面，View</p></li><li><p>@RestController：控制层组件，包含@Controller和@ResponseBody，一般返回JSON</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target({ElementType.TYPE})</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController {……}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@Service：业务层组件</p></li><li><p>@Configuration：配置类</p></li><li><p>@Component：组件类，泛指组件，组件不好归类可以使用这个</p></li></ul></li><li><p>参数注解：</p><ul><li><p>@PathVariable：路径变量。参数与大括号里的名字一样要相同</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">"user/get/mac/{macAddress}"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(<span class="meta">@PathVariable</span> String macAddress)</span></span>{</span><br><span class="line">　　<span class="comment">//do something;</span></span><br><span class="line">　　}</span><br></pre></td></tr></tbody></table></figure></li><li><p>@RequestBody：返回结果直接写入HTTP response body中</p></li></ul></li><li><p>功能性注解：</p><ul><li><p>@Autowired：自动注入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ISysNoticeService noticeService;</span><br></pre></td></tr></tbody></table></figure></li><li><p>@EnableAutoConfiguration：启用自动配置</p></li><li><p>@ComponentScan：指定路径下扫描组件，如果扫描到有@Component @Controller @Service等这些注解的类，则把</p><p>这些类注册为bean</p></li><li><p>@Bean：方法上，返回的对象注入到IOC容器中</p></li></ul></li></ol><p>这些差不多够他喝一壶了吧。。。感觉最常用的都有了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot常用注解&quot;&gt;&lt;a href=&quot;#Spring-Boot常用注解&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot常用注解&quot;&gt;&lt;/a&gt;Spring Boot常用注解&lt;/h1&gt;&lt;p&gt;自己重新整理一下吧。&lt;/p&gt;
&lt;ol</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="https://songx64.github.io/tags/Java/"/>
    
    <category term="Springboot" scheme="https://songx64.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单学习</title>
    <link href="https://songx64.github.io/2021/05/09/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://songx64.github.io/2021/05/09/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-09T14:10:43.000Z</published>
    <updated>2021-06-06T01:39:21.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker简单学习"><a href="#Docker简单学习" class="headerlink" title="Docker简单学习"></a>Docker简单学习</h1><p>这里没叙述安装啥的过程，Linux里面安装很简单的。而且Docker官方文档写的挺明白的。</p><blockquote><p>这个主要看的B站视频：<a href="https://www.bilibili.com/video/BV1R4411F7t9">https://www.bilibili.com/video/BV1R4411F7t9</a></p><iframe src="//player.bilibili.com/player.html?aid=58402749&amp;bvid=BV1R4411F7t9&amp;cid=101870925&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></blockquote><h2 id="Docker概念图"><a href="#Docker概念图" class="headerlink" title="Docker概念图"></a>Docker概念图</h2><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509202234962.png" alt="image-20210509202234962"></p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p>体验学习Docker的一个网站：<a href="https://labs.play-with-docker.com/%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%8E%AF%E5%A2%83%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E3%80%82">https://labs.play-with-docker.com/，提供一个在线环境直接使用。</a></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509213624353.png" alt="image-20210509213624353"></p><p>默认给4小时的学习时间，200是指已经运行的镜像映射的服务器端口。</p><hr><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><ul><li><p>pull nginx 镜像：<code>docker pull nginx</code>（等效于nginx:latest）<br>从远程仓库下载已经有了的镜像</p></li><li><p>查看镜像列表：<code>docker images</code> （本机已有的镜像）或者 <code>docker image ls</code></p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509203714096.png" alt="image-20210509203714096"></p></li><li><p>删除镜像：docker rmi【 name】</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509211840818.png" alt="image-20210509211840818"></p></li></ul><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>运行：<code>docker run 【-d】（后台运行不阻塞shell） 【-p 81:80】（指定容器端口映射，内部：外部） nginx（镜像名）</code><blockquote><p>端口映射是说Docker虚拟机内的端口81，映射到现在服务器的端口80。外部访问服务器端口80，然后服务器再去访问Docker虚拟机的端口81。</p></blockquote></li><li>查看正在运行的镜像（容器）：<code>docker ps</code><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509203923649.png" alt="image-20210509203923649"></li></ul><ul><li><p>进入Docker虚拟机的镜像（容器）中的bash：docker exec -it container id(不用打全，前缀区分) bash</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509204023115.png" alt="image-20210509204023115"></p></li><li><p>删除容器（停止运行）：docker rm -f 【container id】(不用打全，前缀区分)<br><img src="C:/Users/15220/AppData/Roaming/Typora/typora-user-images/image-20210509205659303.png" alt="image-20210509205659303"></p></li><li><p>commit镜像：docker commit  【id】(不用打全，前缀区分)  name<br>镜像修改过之后可以用这个搞一个copy的<br><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509205925321.png" alt="image-20210509205925321"></p></li></ul><h3 id="DockerFile构建新镜像"><a href="#DockerFile构建新镜像" class="headerlink" title="DockerFile构建新镜像"></a>DockerFile构建新镜像</h3><p>编写DockerFile，然后从DockerFile来从已有镜像构建新镜像</p><p>比如我们这里在当前目录<code>./</code>下新建了一个<code>index.html</code>，然后复制到虚拟机中的<code>nginx/html</code>下，替换掉默认的首页。</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从nginx镜像来构建</span></span><br><span class="line"><span class="keyword">From</span> nginx</span><br><span class="line"><span class="comment"># 复制./目录下所有文件，到虚拟机的html文件夹下</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./ /usr/share/nginx/html/</span></span><br></pre></td></tr></tbody></table></figure><p>  <img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509210407064.png" alt="image-20210509210407064"></p><p>使用Dockerfile构建镜像：<code>docker build -t [NewImageName] [存放Dockerfile的文件夹]</code><br>如下，注意最后有个点 <code>.</code> 指的是当前目录</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509210728371.png" alt="image-20210509210728371"></p><p> 最后通过m2的100端口运行一下可以看到新镜像的效果。</p><h3 id="tar文件"><a href="#tar文件" class="headerlink" title="tar文件"></a>tar文件</h3><p>保存为tar：docker save name  tar name</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509211925462.png" alt="image-20210509211925462"></p><p>从tar加载：docker load &lt;  [文件名]</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509213526053.png" alt="image-20210509213526053"></p><p>扩展命令：<code>docker run -d -p 200:80 -v $(pwd):/use/share/nginx/html/ –name test nginx:1.13</code></p><p>使用200映射内部80端口，使用当前路径$(pwd)映射到内部html文件夹下，运行时名称显示test，nginx镜像版本使用1.13</p><p><img src="https://gitee.com/songx86/SongPicBed/raw/master/img/image-20210509212627874.png" alt="image-20210509212627874"></p><ul><li>Powershell下使用：${pwd}</li><li>Linux下使用：$(pwd)</li></ul><iframe src="//player.bilibili.com/player.html?aid=58402749&amp;bvid=BV1R4411F7t9&amp;cid=101870925&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker简单学习&quot;&gt;&lt;a href=&quot;#Docker简单学习&quot; class=&quot;headerlink&quot; title=&quot;Docker简单学习&quot;&gt;&lt;/a&gt;Docker简单学习&lt;/h1&gt;&lt;p&gt;这里没叙述安装啥的过程，Linux里面安装很简单的。而且Docker官方文档</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="运维" scheme="https://songx64.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Docker" scheme="https://songx64.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>influxDB简单学习</title>
    <link href="https://songx64.github.io/2021/05/05/influxDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://songx64.github.io/2021/05/05/influxDB%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-05-05T03:39:43.000Z</published>
    <updated>2021-06-06T01:39:21.190Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下InfluxDB</p><blockquote><p><a href="http://www.linuxdaxue.com/noun-interpretation-of-influxdb.html">InfluxDB学习之InfluxDB的基本概念</a></p><p><a href="https://jasper-zhang1.gitbooks.io/influxdb/content/">InfluxDB中文文档 (gitbooks.io)</a></p></blockquote><h3 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h3><ul><li><strong>极简架构：</strong>单机版的InfluxDB只需要安装一个binary，即可运行使用，完全没有任何的外部依赖。</li><li><strong>极强的写入能力：</strong> 底层采用自研的TSM存储引擎，TSM也是基于LSM的思想，提供极强的写能力以及高压缩率。</li><li><strong>高效查询：</strong>对Tags会进行索引，提供高效的检索。</li><li><strong>InfluxQL</strong>：提供SQL-Like的查询语言，极大的方便了使用，数据库在易用性上演进的终极目标都是提供Query Language。</li><li><strong>Continuous Queries</strong>: 通过CQ能够支持auto-rollup和pre-aggregation，对常见的查询操作可以通过CQ来预计算加速查询。</li></ul><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="一、与传统数据库中的名词做比较"><a href="#一、与传统数据库中的名词做比较" class="headerlink" title="一、与传统数据库中的名词做比较"></a>一、与传统数据库中的名词做比较</h4><table><thead><tr><th>influxDB中的名词</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>database</td><td>数据库</td></tr><tr><td>measurement</td><td>数据库中的表</td></tr><tr><td>points</td><td>表里面的一行数据</td></tr></tbody></table><h4 id="二、InfluxDB中独有的概念"><a href="#二、InfluxDB中独有的概念" class="headerlink" title="二、InfluxDB中独有的概念"></a>二、InfluxDB中独有的概念</h4><h5 id="1）Point"><a href="#1）Point" class="headerlink" title="1）Point"></a>1）Point</h5><p>==Point（一行）==由<strong>时间戳（time）、数据（field）、标签（tags）</strong>组成。  </p><p>Point相当于传统数据库里的一行数据，如下表所示：</p><table><thead><tr><th>Point属性</th><th>传统数据库中的概念</th></tr></thead><tbody><tr><td>time</td><td>每个数据记录时间，是数据库中的主索引(会==自动生成==)</td></tr><tr><td>fields</td><td>各种记录值（==没有索引==的属性）也就是记录的值：温度， 湿度</td></tr><tr><td>tags</td><td>各种==有索引==的属性：地区，海拔（相当于要通过这个进行筛选查询？）</td></tr></tbody></table><h6 id="特别提醒："><a href="#特别提醒：" class="headerlink" title="特别提醒："></a>特别提醒：</h6><ol><li><p>==time 相当于表的主键==，当一条数据的<strong>time和tags完全相同</strong>时候，<strong>新数据会替换掉旧数据，旧数据则丢失</strong>（线上环境尤其要注意）。</p></li><li><p><strong>tags 和time可以作为排序字段，field则不可以</strong>。如：<code>ORDER BY time DESC</code></p></li><li><p>fields和tags的<strong>字段类型</strong>是由存入的第一条记录值决定的。</p><blockquote><p>举例：<br>如第一条记录<code>fieldA</code>的值为2，想插入一条记录，<code>fieldA</code>字段值为3.14的值，就会报错。因为该字段已经被初始化为整型了。<br>如第一条记录<code>fieldB</code>存储的是3,想插入一条记录，<code>fieldB</code>字段值为hello,则也会报错，该字段已被初始化成整型，不能再写入字符串了。</p></blockquote></li><li><p>建议只使用字符串类型和浮点类型，把所有的整型，长整型，浮点型，双精度型统一转为小数格式的浮点类型，再写入数据库，字符串类型的不用做转换，这样就不会出现插入数据失败和丢失数据了。</p></li></ol><h5 id="2）series"><a href="#2）series" class="headerlink" title="2）series"></a>2）series</h5><p>所有在数据库中的数据，都需要通过==图表来展示==，而这个series表示这个表里面的数据，可以==在图表上画成几条线==：通过tags排列组合算出来。 </p><p>如下所示：   </p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span><span class="keyword">show</span> series <span class="keyword">from</span> cpu</span><br><span class="line">key</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu<span class="operator">-</span>total,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu<span class="operator">-</span>total,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu0,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu0,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu1,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu1,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu10,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu10,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu11,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu11,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu12,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu12,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu13,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu13,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu14,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu14,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu15,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu15,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu16,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu17,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu18,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu19,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu2,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu2,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu20,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu21,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu22,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu23,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu3,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu3,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu4,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu4,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu5,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu5,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu6,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu6,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu7,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu7,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu8,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu8,host<span class="operator">=</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu9,host<span class="operator">=</span>ResourcePool<span class="number">-0246</span><span class="operator">-</span>billing07</span><br><span class="line">cpu,cpu<span class="operator">=</span>cpu9,host<span class="operator">=</span>billing07</span><br></pre></td></tr></tbody></table></figure><h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2.基本操作"></a>2.基本操作</h3><p>InfluxDB提供类SQL语法，如果熟悉SQL的话会非常容易上手。</p><h4 id="一、InfluxDB操作方式"><a href="#一、InfluxDB操作方式" class="headerlink" title="一、InfluxDB操作方式"></a>一、InfluxDB操作方式</h4><p>InfluxDB提供三种操作方式：</p><p>1）客户端命令行方式</p><p>2）HTTP API接口</p><p>3）各语言API库</p><p>今天主要以命令行为例，为大家介绍下InfluxDB的基本操作，HTTP API接口和各种语言API库会在以后的文章中为大家详细介绍。</p><h4 id="二、InfluxDB数据库操作"><a href="#二、InfluxDB数据库操作" class="headerlink" title="二、InfluxDB数据库操作"></a>二、InfluxDB数据库操作</h4><p>与sql一样，以下是查增删用</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">show</span> databases</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">create</span> database test</span><br><span class="line"><span class="operator">&gt;</span> <span class="keyword">drop</span> database test</span><br><span class="line"><span class="operator">&gt;</span> use xk_name</span><br></pre></td></tr></tbody></table></figure><h4 id="三、InfluxDB数据表操作"><a href="#三、InfluxDB数据表操作" class="headerlink" title="三、InfluxDB数据表操作"></a>三、InfluxDB数据表操作</h4><p>在InfluxDB当中，并没有表（table）这个概念，取而代之的是MEASUREMENTS，MEASUREMENTS的功能与传统数据库中的表一致，因此我们<strong>也可以将MEASUREMENTS称为InfluxDB中的表</strong>。</p><p>1）显示所有表</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">SHOW</span> MEASUREMENTS</span><br></pre></td></tr></tbody></table></figure><p>2）新建表</p><p>InfluxDB中没有显式的新建表的语句，只能通过insert数据的方式来建立新表。如下所示：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> disk_free,hostname<span class="operator">=</span>server01 <span class="keyword">value</span><span class="operator">=</span><span class="number">442221834240</span>i <span class="number">1435362189575692182</span></span><br><span class="line"># <span class="keyword">insert</span> 表名,索引<span class="operator">=</span>xxx,索引<span class="number">2</span><span class="operator">=</span>xxx value1<span class="operator">=</span>记录值<span class="number">1</span>,value2<span class="operator">=</span> <span class="type">time</span></span><br></pre></td></tr></tbody></table></figure><p>其中 disk_free 就是表名，hostname是索引，value=xx是记录值，记录值可以有多个，最后是指定的时间。</p><p>执行后结果如下</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> disk_free</span><br><span class="line">name: disk_free</span><br><span class="line"><span class="comment">---------------</span></span><br><span class="line"><span class="type">time</span>            hostname    <span class="keyword">value</span></span><br><span class="line"><span class="number">1435362189575692182</span>    server01    <span class="number">442221834240</span></span><br></pre></td></tr></tbody></table></figure><p>以我们的数据来进行类比:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line"><span class="attr">"Serial"</span>: <span class="number">123456</span>,                      <span class="comment">// 设备编号# 索引</span></span><br><span class="line"><span class="attr">"UploadTime"</span>: <span class="string">"2021-01-10 14:24:41"</span>,   <span class="comment">// 上传时间# 索引</span></span><br><span class="line"><span class="attr">"GasType"</span>: <span class="string">"VOC"</span>,                      <span class="comment">// 气体类型# 索引</span></span><br><span class="line"><span class="attr">"DataNum"</span>: <span class="number">2</span>,                          <span class="comment">// 数据条数# ？？？</span></span><br><span class="line"><span class="attr">"Rssi"</span>: <span class="number">30</span>,                            <span class="comment">// 信号值，网络信号 # ？？？</span></span><br><span class="line"><span class="attr">"Datas"</span>: [{                            <span class="comment">// 每条数据的集合# 记录值</span></span><br><span class="line"><span class="attr">"Data"</span>: <span class="number">0</span>,                            <span class="comment">// 数据值# value</span></span><br><span class="line"><span class="attr">"DateTime"</span>: <span class="string">"2021-01-10 14:21:00"</span>,    <span class="comment">// 数据时间# time</span></span><br><span class="line"><span class="attr">"Flw"</span>: <span class="string">"㎎/m³"</span>,                        <span class="comment">// 数据单位# value</span></span><br><span class="line"><span class="attr">"State"</span>: <span class="number">1</span>,                           <span class="comment">// 状态# value</span></span><br><span class="line"><span class="attr">"StateDetail"</span>: <span class="string">"正常"</span>                   <span class="comment">// 状态名称# value</span></span><br><span class="line">}, {</span><br><span class="line"><span class="attr">"Data"</span>: <span class="number">0</span>,</span><br><span class="line"><span class="attr">"DateTime"</span>: <span class="string">"2021-01-10 14:24:00"</span>,</span><br><span class="line"><span class="attr">"Flw"</span>: <span class="string">"㎎/m³"</span>,</span><br><span class="line"><span class="attr">"State"</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">"StateDetail"</span>: <span class="string">"正常"</span></span><br><span class="line">}]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> testiii,Serial<span class="operator">=</span><span class="number">222222</span>,GasType<span class="operator">=</span>VOC Data<span class="operator">=</span><span class="number">0.565</span>,State<span class="operator">=</span><span class="number">2</span>i,StateDetail<span class="operator">=</span>"高报",Flw<span class="operator">=</span>"mg/m3",Rssi<span class="operator">=</span><span class="number">30</span></span><br></pre></td></tr></tbody></table></figure><p>3）查询要注意时区：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> disk <span class="keyword">where</span> <span class="type">time</span> <span class="operator">&gt;=</span> <span class="string">'2018-11-23 14:30:39'</span> <span class="keyword">and</span> <span class="type">time</span> <span class="operator">&lt;=</span> <span class="string">'2018-11-23 14:32:32'</span> tz(<span class="string">'Asia/Shanghai'</span>)</span><br></pre></td></tr></tbody></table></figure><p>按照北京时间查询</p><p>Windows环境下需要安装GO语言，然后重启。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习一下InfluxDB&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.linuxdaxue.com/noun-interpretation-of-influxdb.html&quot;&gt;InfluxDB学习之InfluxDB的基本概念&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="后端" scheme="https://songx64.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="后端" scheme="https://songx64.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="数据库" scheme="https://songx64.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
